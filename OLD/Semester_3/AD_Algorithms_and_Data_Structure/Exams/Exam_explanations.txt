


Huffman Trees

5  4  3  2  1  1
A  B  C  D  E  F

5  4  3  2    2
A  B  C  D    *
             / \
            E   F
            
            
            
            
            
1  2  2  2  2  1  1  2  2  3  1  3  1  1  4
A  C  E  H  I  L  M  N  O  R  S  T  U  Z  _

1  1  1  1  1  1  2  2  2  2  2  2  3  3  4
A  L  M  S  U  Z  C  E  H  I  N  O  R  T  _

  2      2       2    2  2  2  2  2  2  3  3  4
  *      *       *    C  E  H  I  N  O  R  T  _
 / \    / \     / \
A   L  M   S   U   Z



a b r a c a d a b r a !

1  1  1  2  2  5
c  !  d  r  b  a


Здесь в первую очередь нужно понять, что в финальное дерево все символы добавляются в порядке частоты встречания символов
Если частота одинакова, то не важно что первым брать. В алгоритме, который предлагали в лекции, используется приоритетная очередь
Где все значения отсортированы, а порядок для мсиволов с одинаковой частотой определяется, какой символ раньше встретился,
пока подсчитывали к-во символов
1  1  1  2  2  5
c  !  d  r  b  a

1  2    2  2  5
!  *    r  b  a
  / \
 c   d

   3    2  2  5
   *    r  b  a
  / \ 
 !   *    
    / \
   c   d

   
   3       4     5
   *       *     a
  / \     / \
 !   *    r  b
    / \
   c   d

   
 5     7
 a    _* _
     /    \
   3       4     
   *       *     
  / \     / \
 !   *    r  b
    / \
   c   d
   
 
        12
     0 _*_  1
      /   \
     5     7
     a  0 _* _ 1
         /    \
       3       4     
     0 * 1   0 * 1    
      / \     / \
     ! 0 * 1  r  b
        / \
       c   d
       
       
Insertion sort
1) Есть входный данные
2) Считаем что в выходных нету ничего
3) Берем из входных данных текущий символ (первый, потом второй, третий и тд) и ищем ему подходящее место в выходных
4) Вставляем символ в подходящую позицию, выходной поток увеличился на 1 символ
5) Сдвигаем указатель во входящем потоке
6) Повторяем с 3

начальные данные:
dacxszy

входной поток:
dacxszy
_ - это будет указатель текущего символа
выходной поток:
пусто

входной поток:
dacxszy
_
выходной поток
d

входной поток:
dacxszy
 _
выходной поток
ad

входной поток:
dacxszy
  _
выходной поток
acd

входной поток:
dacxszy
   _
выходной поток
acdx

входной поток:
dacxszy
    _
выходной поток
acdsx

входной поток:
dacxszy
     _
выходной поток
acdsxz

входной поток:
dacxszy
      _
выходной поток
acdsxyz


2-3-4-tree

ahrtelrkww



Быстрая сортировка (Quicksort)
Суть его предельно проста: выбирается так называемый опорный элемент, и массив делится на 2 подмассива:
меньших опорного или равных опорному и больших опорного. Потом этот алгоритм применяется рекурсивно к подмассивам. Упрощенная версия

Начальный массив arr
5 3 7 1 4 9 6 2 8
  
Опорным элементом можно взять любой. Для простоты будем всегда брать средний. Можно вообще взять случайный индекс каждый раз - не важно.
Скорость работы алгоритма зависит от удачно подобранного опорного элемента и может быть выше или ниже, но нам сейчас это не принципиально.
Следовательно, всегда будем брать средину подмассива, с которым сейчас работаем. Вначале подмассивом является весь массив

5 3 8 1 4 9 6 2 7
        _

pivot = 4
l = 0 r = 8  где l и r - это левый и правый индексы текущего подмассива (т.е. 5 - нулевой элемент массива, а 7 - восьмой)
На каждом большом круге делаем такое:
1) Пока arr[l] < pivot делай l = l + 1
2) Пока arr[r] > pivot делай r = r - 1
3) Если l <= r - обменяй местами значение arr[l] и arr[r], после этого l = l + 1, а  r = r - 1
4) Если l <= r - вернись на первый пункт. Судя по всему наличие знака равно принципиально, 

и так, имеем:
5 3 8 1 4 9 6 2 7
        _
После пунка 1) l как было 0, так им и осталось, так как условие не выполняется сразу
После пункта 2) r = 7, так как ((arr[8] == 7) > (pivot == 4), а arr[7] == 2 < (pivot == 4)
Так как l = 0 < r = 7, то меняем местами arr[0], arr[7] и получаем
2 3 8 1 4 9 6 5 7
        _
выполняя l = l + 1 и r = r - 1 получаем l = 0+1 = 1, r = 7 - 1 = 6 и возвращаемся к пункту 1)
      
После пунка 1) l = 2, так как arr[1] == 3 < (pivot == 4), и arr[2] == 8 > (pivot == 4)
После пункта 2) r = 4, так как ((arr[6] == 6) > (pivot == 4), ((arr[5] == 9) > (pivot == 4), а ((arr[4] == 4) == (pivot == 4)
Так как l = 2 < r = 4, то меняем местами arr[2], arr[4] и получаем
2 3 4 1 8 9 6 5 7
    _   
    
выполняя l = l + 1 и r = r - 1 получаем l = 2 + 1 = 3, r = 4-1=3 Так каи l уже не меньше r, то ни этом обработка этой фракции заканчивается
После этого все вышеописанные действия продолжаются над двумя кусками, один от 0 до r, второй от r+1 до конца массива
Если своими словами. Каждый раз мы делим наш массив на две части, по индексу r. В часть 0..r попадает все, что меньше равно опорного элемента
В правую часть (от r+1 до конца) попадает все, что больше. После чего мы сортируем каждую части таким же образом

было 3, 5, 8, 1, 4, 9, 2, 6, 7
после первого шага получим
3 2 4 1 8 9 5 6 7 
после чего вызовем сортировку для первой половины 3 2 4 1 и для второй 8 9 5 6 7 
для 3 (2) 4 1 опорным будет элемент с индексом (0 + 3)/2 = 1 - это число 2 из массива 3 2 4 1 8 9 5 6 7 
тогда получим 1 2 4 3
для второй 8 9 (5) 6 7 опорным будет элемент с индексом (4 + 8)/2 = 6 - это число 5 из массива 3 2 4 1 8 9 5 6 7 
(5) 9 8 6 7
после этого больше менять нечего, так как справа уже все элементы, которые больше 5
следующим шагом будем сортировать массив 9 (8) 6 7 опорным будет элемент с индексом (5 + 8)/2 = 6 - это число 8 из массива 1 2 4 3 5 9 8 6 7
7 (8) 6 9
давай для простоты будем считать, что у нас есть только этот маленький массив, это не будет влиять на то, как обработает его программа
но тебе будет проще понять
в самом начале у на есть 9 (8) 6 7
l = 0; r = 3

Выполняем предписание:
1) Пока arr[l] < pivot делай l = l + 1
2) Пока arr[r] > pivot делай r = r - 1
3) Если l <= r - обменяй местами значение arr[l] и arr[r], после этого l = l + 1, а  r = r - 1
4) Если l <= r - вернись на первый пункт. Судя по всему наличие знака равно принципиально, 
Так как 9 сразу больше чем 8, то мы ни разу не прибавляем к l 1
Переходим к шагу 2, так как сразу 7 < 8, то мы ниразу не уменьшаем r
меняем местами крайние эелементы, так как именно на них указывают неизмененные индексы l = 0 r = 3
7 (8) 6 9
l=0+1=1   r=3-1=2
Снова выполняем 
1) Пока arr[l] < pivot делай l = l + 1
2) Пока arr[r] > pivot делай r = r - 1
3) Если l <= r - обменяй местами значение arr[l] и arr[r], после этого l = l + 1, а  r = r - 1

1)Так как сразу 8 не меньше 8, то не изменяем l
2)Так как сходу 6 не больше 8, то не изменяем r
3) меняем местами 8 и 6, получаем
7 6 (8) 9
l=1+1=2   r=2-1=1
Условие l <= r больше не выполняется, следовательно заканчиваем с этим массивом и возвращаем число r = 1

1 2 4 3 5 7 6 8 9 
После этого мы попросим отсортировать массивы 7 6 и 8 9
Первый поменяет местами 7 и 6 , а второй уже и так отсортирован
В конце получим 1 2 4 3 5 6 7 8 9 

Здесь сверху то, что было, затем индексы, которые сортируем и далее строка, что получилось
То есть когда написано Partition - это значит нужно в строке выше посмотреть, что сортировали, а на строку ниже - что получилось

5 3 8 1 (4) 9 6 2 7
Partition 0, 8  опорный (0+8)/2=4  то есть цифра 4
3, (2), 4, 1, 8, 9, 5, 6, 7,
Partition 0, 3  опорный (0+3)/2=1  то есть цифра 2 
1, (2), 4, 3, 8, 9, 5, 6, 7,
Partition 1, 3  опорный (1+3)/2=2  то есть цифра 4
1, 2, 3, (4), 8, 9, 5, 6, 7,
Partition 1, 2  опорный (1+2)/2=1  то есть цифра 2
1, 2, 3, 4, 8, 9, 5, 6, 7,
Partition 4, 8  опорный (4+8)/2=6  то есть цифра 5
1, 2, 3, 4, 5, 9, 8, 6, 7,
Partition 5, 8
1, 2, 3, 4, 5, 7, 6, 8, 9,
Partition 5, 6
1, 2, 3, 4, 5, 6, 7, 8, 9,
Partition 7, 8   опорный (7+8)/2=7  то есть цифра 8
1, 2, 3, 4, 5, 6, 7, 8, 9,


        int[] data = {3, 5, 8, 1, 4, 9, 2, 6, 7};
        QSort<int>.Sort(data);
        for(var i = 0; i < data.Length; ++i)
            Console.Write("{0}, ", data[i]);

        public static void Sort(T[] arr)
        {
            Sort(arr, 0, arr.Length - 1);
        }

        private static void Sort(T[] arr, int l, int r)
        {
            if (l < r)
            {
            //Вызов Partition возвращает нам индекс как поделился массив + перемещает в левую часть элементы меньше опорного, а в правую - больше
                int q = Partition(arr, l, r);
                if (q != r)
                    //теперь сортируем левую часть
                    //здесь проверка как и внизу - защита от зацикливания
                    l = 1 r = 3, если q вернется 3, то снова будет вызвана функция Sort(1, 3) - именно такая же была вызвана ранее
                    Sort(arr, l, q);
                if (q + 1 != l)
                    //сортируем праую часть
                    //проверка нужна для ситуации, когда может произойти зацикливание, что снова вызываем рекурсию для диапазона, который мы обрабатывали перед этим
                    Sort(arr, q + 1, r);
            }
        }

        private static int Partition(T[] arr, int b, int e) //b -> beginning e -> end
        {
            Console.WriteLine("Partition {0}, {1}", b, e);
            var pivot = arr[(b + e)/2];
            int l = b;
            int r = e;
            while (l <= r)
            {
                while (arr[l].CompareTo(pivot) < 0)
                    l++;
                while (arr[r].CompareTo(pivot) > 0)
                    r--;
                if (l <= r)
                {
                    var t = arr[l];
                    arr[l] = arr[r];
                    arr[r] = t;
                    ++l;
                    --r;
                }
            }

            return r;
        }
    }

d, z, e, r, o, l, w, b, k
Partition 0, 8
d, k, e, b, l, o, w, r, z,
Partition 0, 4
d, b, e, k, l, o, w, r, z,
Partition 0, 1
b, d, e, k, l, o, w, r, z,
Partition 2, 4
b, d, e, k, l, o, w, r, z,
Partition 3, 4
b, d, e, k, l, o, w, r, z,
Partition 5, 8
b, d, e, k, l, o, r, w, z,
Partition 5, 6
b, d, e, k, l, o, r, w, z,
Partition 7, 8
b, d, e, k, l, o, r, w, z,


'Q', 'E', 'T', 'U', 'O', 'A', '(N)', 'G', 'J', 'L', 'X', 'V', 'D'
Partition 0, 12 опорный (0+12)/2=6 то есть буква N
D, E, (L), J, G, A, N, O, U, T, X, V, Q,
Partition 0, 5 опорный (0+5)/2=2 то есть буква L
D, E, A, J, G, L, N, O, U, T, X, V, Q,
Partition 0, 4
A, E, D, J, G, L, N, O, U, T, X, V, Q,
Partition 1, 4
A, D, E, J, G, L, N, O, U, T, X, V, Q,
Partition 2, 4
A, D, E, G, J, L, N, O, U, T, X, V, Q,
Partition 2, 3
A, D, E, G, J, L, N, O, U, T, X, V, Q,
Partition 6, 12
A, D, E, G, J, L, N, O, Q, T, X, V, U,
Partition 6, 8
A, D, E, G, J, L, N, O, Q, T, X, V, U,
Partition 7, 8
A, D, E, G, J, L, N, O, Q, T, X, V, U,
Partition 9, 12  опорный (9+12)/2=10  то есть буква X
A, D, E, G, J, L, N, O, Q, T, U, V, X,
Partition 9, 11  опорный (9+11)/2=10  то есть буква U
A, D, E, G, J, L, N, O, Q, T, U, V, X,
Partition 10, 11 
A, D, E, G, J, L, N, O, Q, T, U, V, X,


InsertionSort

 i t w a s b e s t
 i t                1 comp 0 swap
 i t w              1 comp 0 swap
 a i t w            3 comp 3 swap
 
 MergeSort
 
 i t | w a | s b | e s | t
 i t | a w | b s | e s | t
 i t a w 
 
 
 2 8 1 4 | 3 7 5 6
   ___
 2 1 8 4   сравниваем 1 и 8
 ___
 1 2 8 4   сравниваем 1 и 2
     ___
 1 2 4 8   сравниваем 4 и 8
 итого 3 сравнения
              ___ 
            3 7 5 6
                ___
            3 5 7 6
            
            3 5 6 7   итого 2 сравнения
       ___            
 1 2 4 8 3 5 6 7
     ___
 1 2 4 3 8 5 6 7
         ___ 
 1 2 3 4 8 5 6 7
           ___
 1 2 3 4 5 8 6 7
             ___
 1 2 3 4 5 6 8 7
 
 1 2 3 4 5 6 7 8  итого 5 сравнений
 
 3.2. Слияние двух подмассивов в третий результирующий массив.
На каждом шаге мы берём меньший из двух первых элементов подмассивов и записываем его в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят элемент, увеличиваем на 1.
3.3. «Прицепление» остатка.
Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив.

слияние
2 8    1 4
_      _ 
 
сравниваем 2 и 1 и записываем 1 как меньшее число, индекс в правом массиве сдвигаем вправо
1
сравниваем 2 и 4, записываем 2, как меньшее число и индекс в левом массиве сдвигаем вправо, получаем
1 2 
сравниваем 8 и 4, записываем 4, как меньшее, правый массив закончился, следовательно после этого все, что было слева дописываем к результату
1 2 4 8

1 2 4 8   3 5 6 7
      _         _

сравниваем 1 и 3 и записываем 1 как меньшее число, индекс в левом массиве сдвигаем вправо
1 
сравниваем 2 и 3 и записываем 2 как меньшее число, индекс в левомом массиве сдвигаем вправо
1 2
сравниваем 4 и 3 и записываем 3 как меньшее число, индекс в правом массиве сдвигаем вправо
1 2 3
сравниваем 4 и 5 и записываем 4 как меньшее число, индекс в левом массиве сдвигаем вправо
1 2 3 4
сравниваем 8 и 5 и записываем 5 как меньшее число, индекс в правом массиве сдвигаем вправо
1 2 3 4 5
сравниваем 8 и 6 и записываем 6 как меньшее число, индекс в правом массиве сдвигаем вправо
1 2 3 4 5 6
сравниваем 8 и 7 и записываем 7 как меньшее число, индекс в правом массиве сдвигаем вправо
1 2 3 4 5 6 7 8
(Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы второго подмассива в результирующий массив,
т.е. не только 7, но и 8 сразу добавляем)

