//somewhere in program
//Tree treeA = new Tree("1/sqrt(2*pi/a)*exp(-(a*t^2-b)*cos(2*pi*t/c))");
//        treeA.postOrderTraverse();
//        System.out.printf("result expression is <%s>\n", treeA.GetExpression());
//
// под call имеют в виду treeA.GetExpression()


public class Tree
{
    private Node root;
    //это не дерево в польской нотации или скобочной
    //это результат, который сгенерирует функция postOrderTraverse() после своего вызова
    //именно так просят в задании
    private String expression;
    //именно по-этому, я создал геттер для этого поля, чтобы после вызова, можно было прочитать значение

    //здесь для полностью рабочей программы не хватает конструктора
    //для экзаменационного задания он был неважен, препод хотел понять, знаешь ли ты, что такого обход дерева
    //так что в самом задании его писать не було нужды и я его даже не создавал, но для законченной программы
    // он нужен

    //прикол в том, что ты думаешь даже не в ту сторону
    //есть простые конструкторы, в которые передают что-то и они этот что-то копируют в свои поля
    //здесь же нужен конструктор, который получает текстовую строку! и из нее строит дерево
    //тектовая строка может быть как арифметическое выражение в польской нотации, которую проще разобрать
    //и превратить в дерево, или в скобочной, код достаточно большой и его можно посмотреть в лабе
    public Tree (String expressionInSomeNotation)
    {
        //here must be code to build tree from string expressionInSomeNotation
    }

    //Для того, чтобы тот, кто создаст объект класса Tree, мог вывести это дерево в postOrder
    //мы делаем специальный public метод без параметров, так как единственно верный параметром
    //есть вызвать этот метод для его корня. Корень root можно конечно тоже сделать public и тогда
    //два метода делать не обязательно, но тогда работа с классом усложнится немного,
    // так, если у нас в main создай объект Tree treeA = new Tree();
    // мой вариант (с одним паблик методом и одним приватным) предусматривает вызов
    //treeA.postOrderTraverse()
    //а вариант с удной функцией уже требует вызова
    //treeA.postOrderTraverse(treeA.root);
    //казалось бы, не сложно, зато не нужно два метода
    //вот только класс создается один раз, а методы к нему, обычно, вызываются десятки раз и экономия
    //во времени в будущем того стоит
    //всегда, если можно немножко сделав работы в классе, упростить вызов методов, упрощай ;)!
    //это не 100% правило для экзамена, но это совет человека с 23 годами опыта ;)
    //т.е. способ treeA.postOrderTraverse() предпочтительнее для библиотечной функции, с которой будут
    // работать часто
    public void postOrderTraverse()
    {
        //эта строка нужна для того, чтобы после каждого вызова treeA.postOrderTraverse() мы начинали с пустой
        //строки expression, к которой внутри мы будем прибавлять символы при обходе дерева
        //если этого не делать, то второй вызов будет прибавлять к результату первого
        expression = "";
        //это очень частый трюк с рекурсивными по своей сути методами
        //делаем стартовый метод, который делает предварительную подготовку перед вызовом
        //и значет с какого значения начинать
        postOrderTraverse(root);
    }

    //если здесь не указано приват или паблик, то это автоматом private
    void postOrderTraverse(Node x)
    {
        //нужно создать еще один класс Node
        if( x != null )
        {
            postOrderTraverse(x.left); //вызываем этот же код для левого узла
            postOrderTraverse(x.right); //вызываем этот же код для правого узла
            expression = expression + " " + x.data; //и только после обработки обоих веток прибавляем значение
            //текущего узла к выражению
        }
    }
}

//здесь будет псевдокод
//для дерева
//          A
//        B   C
//       D E F G
//postOrderTraverse(A) - на самом деле мы вызываем не для буквы A, а для объекта Node, у которого поле data = A
//после этого мы видим вызываем этот же метод для его левого узла, это B. На стеке ссохранится 2 вызова
//прошлый и новый
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//но мы снова заходим в левый узел для узла B, это узел D, на стеке вызовов (call stack)
// сохранится еще один вызов и он будет выглядеть
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//postOrderTraverse(D) - и от еще одного
//после этого заходим в левый узел для узла D, а там пусто, но тем не менее, до входа туда мы этого не знаем
// и на call stack сохранится еще один вызов
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//postOrderTraverse(D) - и от еще одного
//postOrderTraverse(null) - от левого узла для D
//этот вызов происходит в холостую, так как условие if (node != null) не дает функции ничего сделать и мы возвращаемся
//из этого вызова в то место, откуда он был вызван
//это убирает последний вызов с call stack
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//postOrderTraverse(D) - и от еще одного
//мы находимся внутри метода postOrderTraverse для узла D, но уже в месте, перед вызовом команды postOrderTraverse(x.right);
//после этого вызова call stack снова выглядит
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//postOrderTraverse(D) - и от еще одного
//postOrderTraverse(null) - но уже от правого узла для D
//этот вызов так же холостой и мы снова возвращаемся назад в postOrderTraverse(D), но уже перед командой
//expression = expression + " " + x.data; которая и добавит самый первый, текущий символ D в пустую,
// до этого строку.
//в этот момент call stack выглядит пока как
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//postOrderTraverse(D) - и от еще одного
//но так как на этом метод postOrderTraverse(D) завершается и мы из него попадаем в вызов postOrderTraverse(B),
//но уже перед вызовом команды postOrderTraverse(x.right); call stack выглядит
//postOrderTraverse(A) - это осталось от первого вызова
//postOrderTraverse(B) - а это уже от нового
//тогда как D хранится в переменной expression