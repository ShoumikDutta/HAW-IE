Приоритет операторов запомнить непростое дело, я вот до сих пор не знаю приоритета всех
В разных языках он может отличаться
Потому, каждый раз, когда сомневаешься в приоритете - ставь скобки - не ошибешься ;)

В таблице приоритетов показаны - и * два раза. Дело в том, что они могут иметь разный смысл в зависимости от того, где они стоят
более высокий приоритет у унарных операторов. Так команда -5 или -someVariable говорит, что значению нужно сменить знак
* перед именем переменной - это признак указателя
а звездочка между операндами - умножение

Перечисления в языке C сделаны по дурацки по сравнению с другими языками. Просто язык старый и решили ничего не менять
Только в С++ их значительно расширили. Приведу пример идиотизма

Так объявляется энум(перечисление).
enum strategy {RANDOM, IMMEDIATE, SEARCH};

Но на самом деле такая запись равносильна записи
RANDOM = 0
IMMEDIATE = 1
SEARCH = 2
Фактически язык Си создает константы, а не что-то типа класса с несколькими вариантами значений
С одной стороны, такими перечислениями проще оперировать
так переменной просто присваиваем имя константы без указывания типа перечисления, которого по сути не существует
strategy someVar = IMMEDIATE;

Проблема кроется в том, что нельзя создать два перечисления, у котороых будут совпадающие значения!
enum strategy {RANDOM, IMMEDIATE, SEARCH};
enum TIMER_STRATEGY {LATER, NEXT_TICK, IMMEDIATE};

в Java так делать можно, так как при указывании зачения нужно писать имя перечисления и таким образом обеспечивается уникальность именем
в Си такое не работает. Печаль однако

На слайде с вещественными типами показано из каких частей состоят числа с плавающей запятой
Любое дробное число можно представить в виде mantissa*10^exponent
Например 12345 = 0.12345*10^5. Mantissa = 0.12345, exponent = 5 в этом случае.
На слайде показано, какие биты зарезервированы под хранение мантиссы и экспоненты для каждого типа данных
Чем больше бит выделено под мантиссу - тем больше знаков после запятой можно сохранить. Это касается не обязательно дробных чисел
Представим себе, у нас есть число 123 456 789.
Тип float использует для хранения мантиссы биты с 0 по 22. Этого достаточно для хранения числа равного 2^22 = 4194304
Следовательно больше 7 знаков после запятой этот тип сохранить не может.
Тогда если записать число 123 456 789 в float он преобразует его в дробь где поместится только первые 7 чисел 123456700
Остальное будет дополнено нулями. Для хранения экспоненты используется биты с 23 по 31 = 9 бит. 2^9 = 512. Нигде не встречал
объяснение, почему столько бит сохраняет только число в диапазоне -38 до 38, но общую идею понять можно.
Чем больше число бит по степень - тем большего порядка можно сохранить числа. Но к-во значимых знаков зависит от размера мантиссы.
В результате float a = 123 456 789; сохранится в виде 0.12345700*10^9. Уже сама запись значения в вещественный тип данных может привести 
к потере части значения, если мантисса окажется недостаточно большой.
int b = (int)a; b = 123 456 700; Произойдет потеря части значения.
Самый старший бит в числах, которые не помечены как unsigned используется для знака. Если там 0 - это положительное число.
Если 1 - отрицательное. Таким образом signed переменные могут использовать для хранения значений на 1 бит меньше и их максимальные
и минимальные значения будут в 2 раза меньше чем у unsigned эквивалентов
Пример
unsigned byte = 8 бит. Знака нет, следовательно для числа используется все 8 бит. Это дает максимальное число 2^8-1 = 255
signed byte = 8 бит. Но так как старший бит это признак знака, по под значение остается только 7 бит и это дает максимальное 
число 2^7-1 = 127

По индианам
0x02FF80
0x02FF84
0x02FF88
Это адреса ячеек памяти. Это просто отображение кусочка оперативной памяти.
Так как между ними 4 байта, то в каждой строке по 4 ячейки. Каждая ячейка это 1 байт.
Запомни, что когда используются 16битные числа (с буквами) то два символа = 1 байт
short int a = 20000; // 0x4E20 - это 16ричное представление числа 20000, чтобы понимать какой байт в какую ячейку попадает
long int b =300000; // 0x000493E0 - это 16 ричное представление числа 300000
тип short int занимает 2 байта (ячейки). 
Тип long int (в С++ можно сокращать до long, но не знаю, можно ли в Си) занимает 4 байта (ячейки).

Little endian: Advantage: variable type (size) can be changed without changing start address of variable)
Здесь о том, что если первыми в памяти идут старшие биты числа, как нам представлять проще, то при приведении числа к меньшему 
типу данны (long => short) происходит обрезание старших бит, чтобы отобразить такое значение
Было 000493E0, остается 93E0. Сама переменная ссылается на тот же самый адрес памяти.
0x02FF80  000493E0
          _ сюда (на ячейку памяти 0x02FF80) указывает переменная типа long.
		      _здесь (в ячейке 0x02FF82) начинается значение приведенное к типу short,
			    но переменная все так же будет указывать на ячейку памяти 0x02FF80 и
				придется проводить дополнительные действия, чтобы получить
				новое значение (сдвигаться)
Если же используется little endian
0x02FF80  E0930400 
То после приведения к меньшему типу данных ардрес младших бит значения всегда остается 0x02FF80
		  _ сюда (на ячейку памяти 0x02FF80) указывает переменная типа long.
		  _ здесь же (в ячейке 0x02FF80) начинается значение приведенное
		     к типу short - это значение E093
		  _ и здесь же (в ячейке 0x02FF80) начинается значение приведенное
		     к типу byte - это значение E0
			  
Intel x86 - это собирательное имя для всех процессоров, которые используются в персональных компьютерах
Intel 64bit обратно совместим с Intel x86. Следовательно на них так же little endian

Кратенько по массивам
Когда ты создаешь массив, ты обязан указать сколько элементов в нем будет хранится. Таким образом программа понимает
сколько байт памяти нужно выделить под массив.
Имя массива всегда указывает на самое начало блока памяти выделенного под массив. В языке Си - это по сути указатель.
Мы позднее увидим, что все что умеют массивы, можно совершить при помози указателей
Если же мы указываем после имени массива квадратные скобки - в них говорится, на сколько элементов от начала массива нужно 
сместится вправо(вниз). На самом деле направление зависит от того, как нарисована память, но обычно ее рисуют сверху вниз и слева
направо (таблица).

Address    value
0x0002FF80 B0 1D
0x0002FF82 FA CE
0x0002FF84 CA 85
0x0002FF86 DE AF
0x0002FF88 AB BA
0x0002FF8A 8E A8
В этом представлении нужно смотреть на адреса, разница между ними говорит сколько байт в строке 0x0002FF82 - 0x0002FF80 = 2 байта
B0 - первый байт 1D - второй байт
У нас число unsignet long int, следовательно ему нжуно 4 байта или 2 строки в таком представлении.
Эту же таблицу можно написать так:
Address    value
0x0002FF80 B0 1D FA CE
0x0002FF84 CA 85 DE AF
0x0002FF88 AB BA 8E A8
Не знаю почему препод сразу так не нарисовал. С другой стороны, ты должен быть готов видеть, сколько именно байт в каждой строке
и научить смотреть на адреса начала каждой строки
Теперь по поводу адресов и значений. Если есть такое описание и массив был выделен начиная с адреса памяти 0x0002FF80
unsigned long int arr1[3];
То запись 
arr1 
означает "спросить по какому адресу памяти начинается массив". Ответ: 0x0002FF80
этот адрес у массива не меняется никогда, после того, как он был раз присвоен!
Используя оператор & можно получить адрес и остальных элементов массива
&arr1[0] даст тот де ответ, что и arr1. Не путать с arr1[0] - это "спросить значение по этому адресу"!
а & - "спросить адрес переменной"!

Give the values of following expressions:
Обозначает ответить на вопрос, что вернет так или иная команда.
В случае с массивами это может быть два типа значений либо значение элемента (когда просто квадратные скобки arr1[1])
либо адрес этого элемента, если используется & либо имя массива без зничего! Адрес это тоже значение!
Просто от наличия [] или &  компилятор понимает какое из двух значений нам нужно.
Это классический случай двойственности указателей. Их прямым значением всегда является адрес.
Но когда используется звездочка, то мы так говорим "дай значение записанное по этому адресу памяти"

Еще раз, рассмотрим наш пример и варианты ответов
arr1[0] вернет B0 1D FA CE
arr1[1] вернет CA 85 DE AF
arr1[2] вернет AB BA 8E A8
arr1 равно как и &arr1[0] вернет 0x0002FF80
&arr1[1] вернет 0x0002FF84
&arr1[2]. Что вернет? 0x0002FF88

arr[3] - это не от 0 до 3, а от 0 до 2    <=========!!!!!!!!!!!!!!!!!!!
Следовательно, написать arr1[3] физически можно, но фактически мы полезем в область памяти, которая под массив не была выделена
И прочитаем/изменим другую переменную, что рано или поздно приведет к ошибкам работы программы

В языке Си и С++ в чистых массивах нету котроля вхождения индекса массива в допустимый диапазон. И такие ошибки сложно вылавливать.
Считается, что на нем пишут профи, они таких ошибок не делают. Все в угоду скорости.

arr[-1]. Как ты думаешь, что может это обозначать?
С массива нужно понимать главное, в квадратных скобках указывают на сколько элементов от начала массива нужно сдвинуться.
Если число больше 0 - то сдвиг происходит вниз, в строну увеличения адреса, а если меньше - то вверх, адрес уменьшается.
Если указать число большее чем к-во элементов в массиве - мы получим каки - то блок памяти за пределами массива.
А если меньше 0 - тоже блок за пределами массива но перед массивом.
Получается, что отрицательный индекс, если говорим о массиве, всегда за пределами массива, а положительный только тогда, 
когда он больше или равен длинне массива.
Здесь учтоняю "если говорим о массиве" потому, что при работе с указателями отрицательное смещение нормальная практика.
Указатель ведь может быть на любой элемент массива, например на последний. Тогда -1 даст предпоследний элемент.
-3 даст элемент который за 3 позиции до конца. При работе с указателями точно так же можно выйти за пределы выделенной памяти
и отследить это еще сложнее, ну да будем как-то разбираться.

Последнее, что здесь следует сказать. Очень много ошибок, которые позволяет увидеть компилятореще до запуска программы. В таком случае
жить проще, так как такие ошибки легко увидеть. Но вот ошибки неверного индекса массива компилятор никак отследить не может, а
в случае языка Си и принципиально не хочет, считая, что это снизит скорость работы программы. Такие ошибки проявляются не сразу
иногда прогамма будет иметь такую ошибку, но она выскочит не в момент перезаписи памяти, а намного позднее, например, когда она
уже закрывается. Так что здесь может быть только один совет - писать обращение по индексу очень внимательно.

УКАЗАТЕЛИ
===============================
Главное что нужно понимать, указателю нельзя присвоить ничего другого кроме как адрес памяти. 
1) Адрес памяти можно получить используя оператор &. этот оператор можно применять вообще к чему угодно. Он возвращает адрес
блока памяти с которого начинаются данные, которые хранятся в этой переменной.
Когда мы создаем любую переменную любого типа, она не явно для нас, выделяет область памяти, который начинается с какого-то адреса
Нас мало интересует конкретное число адреса. Нас может интересовать только что конкретно по этому адресу хранится.
И для того, чтобы получить возможность изменить данные, которые хранятся в переменной мы можем либо использовать саму переменную
либо присвоить ее адрес указателю и далее через указатель, косвенно, делать все тоже самое с этой переменной.
2) Адрес памяти можно присвоив указателю другой указатель, который ранее получил через оператор & адрес какой-то переменной
При присваивании указателя указателю оператор & НЕ ИСПОЛЬЗУЮТ! Дело в том, что указатель - это просто специальная переменная,
под которую тоже выделяется память (обычно 4 байта, не зависимо от того, на какой тип данных она указывает), у которой тоже есть
адрес, но этот адрес нужен только для указателей ни указатели (именно так реализованы двухмерные массивы) и сейчас нам это не нужно.
Так вот, еще раз, значением указателя, является адрес другой переменной. В самом начале указатель хранит како-йто случайный адрес
и его использовать нельзя. По-этому, после создания указателя, прежде чем его использовать, ему нужно присвоить адрес 
какой-то переменной! Именно по-этому если нужно одному указателю присвоить значение другого, просто пишут p1 = p2; без &!!!


Properties -> Advanced -> Compile as C   <---- !!!!!!!!!!!!!!!!!!

int a = 100;
int *p;
p = &a;
После этих команд, не важно, что меняется, значение переменной a или через указатель *p = someValue, обе переменные будут возвращать
одно и тоже значение. Здесь прикол именно в том, что мы используем *p - значение по адресу, на который указывает указатель, 
в данном случае это переменная a.
Для того, чтобы отвязать указатель, ему можно присвоить адрес другой переменной, тогда ситуация повторится, но уже для той переменной


Предлагаю на этом закончить урок, так как ты только что получил столько информации, что ее нужно уложить в голове.
Может лучше просто посидишь сам над кодом и еще раз все проанализируешь?
Я не настаиваю, просто как предложение.

++i  i++
int i = 0;			
for( ; i < 4; i++)	
int i = 0;			
for( ; i < 4; ++i)	
Для цикла for нету разницы как написать в последней секции ++i или i++. Так же нету связи между 
int i = 0;			
for( ; i < 4; ++i) 
int i;	
for(i = 0 ; i < 4; ++i)
int i = 0;			
for( ; i < 4; i++)
int i;	
for(i = 0 ; i < 4; i++)
Все циклы равны, скорее всего абсолютно, зависит от компилятора.
Прикол в том, что ++i если не оптимизировать, немного быстрее, именно по-этому я предпочитаю его в циклах.
Что-бы понять почему он быстрее, напиши метод, который изменяет значение переменной на 1 и возвращает измененное значение 
и еще один метод, который изменяет значение переменной на 1, но возвращает предыдущее значение

Но так как это очень частая операция, то компилятор ее выполняет, скорее всего через регистры процессора,где все одинаково быстро
Так что, если коротко, разницы между 4мя циклами нету никакой!!!!

Разница есть только в выражениях, где ты и изменяешь i и хочешь получить значение этой переменной i
Например:

int i = 0;//i = 0, в этот момент переменной a еще не существует
int a = ++i;//переменной i присваивается значение ни 1 больше чем было, не важно это команда ++i или i++
			//здесь переменная a создается и ей тут же присваивается значение 1, так как использован оператор ++i. 
			//Этот оператор сначала изменяет значение переменной i и потом уже возвращает это значение тому,
			//Следовательно, после этой команды a = 1 i = 1
int b = i++;// оператор i++ сначала возвращает это значение переменной b, а затем изменяет значение переменной i
			// => после этой команды b = 1 i = 2 
		
int i = 10;
int a = i++;
int b = ++i;

i=12
a=10
b=12