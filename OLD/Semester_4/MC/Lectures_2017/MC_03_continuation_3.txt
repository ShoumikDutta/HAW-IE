#define GRAV_CONST 6.674e-11 /* gravitational constant */
#define ASIZE 120 /* array size */
#define DEBUG_OUT_L1 /* level1 debug output */

В языке Си для констант используется не совсем современный способ определения констант через #define
Уже в языке C++ очень рекомендуют не использовать #define для констант, так как они не имеют типа и компилятор не может
работать с ними так же, как с настоящими константами, но в языке Си выбора нет, это расплата за то, что языку очень много лет.
В чем прикол дефайнов?
Представь себе, что ты придумываешь себе текстовые метки, которые равняются чему-то осознанному
например метка ASIZE равняется размеру массива, который ты будешь использовать позднее в программе
Ты создаешь дефайн #define ASIZE 120 и далее везде в программе вместо того, чтобы писать 120, везде пишешь более читабельное
ASIZE. Ну либо даешь более читабельное значение, главное, чтобы тебе самому было понятно, что оно обозначает.
Когда в коде просто написано 120 - это называется использовать magic number. В момент написания программы еще понятно, что это за 
120, но пройдет время и ты забудешь.
Так вот, после того, как запускается процесс компиляции, препроцессор до начала компиляции проходится по всей программе и везде, 
где встречает метку из дефайна, подставляет то, что стоит справа от него (для ASIZE 120 - это 120)
Это не число 120, это замена в коде программы ASIZE на 120.
После того, как все замены произведены - начинается процесс компиляции, которому уже на страшно, что нету имен переменных

Из этого правила выпадает только #define DEBUG_OUT_L1. Он преследует другие цели. Это инструмент условной компиляции
У него справа нит никакого значение, здесь самим значением является имя константы
Она потом используется в коде в виде конструкций
#ifdef DEBUG_OUT_L1
printf(“GRAV_CONST=%f\n“,cArray[3]);
#endif
Что говорит эта конструкция?
Если выше ты определил константу DEBUG_OUT_L1, то строчка printf(“GRAV_CONST=%f\n“,cArray[3]); будет добавлена в программу
Если же не определил, то не будет и это сообщение не будет выводится в собранной программе.

Когда такое нужно?
Например у тебя есть программа для пользователей, которая должна работать максимально быстро. Но тебе иногда нужно отлаживать эту
программу
В коде ты пишешь в тех местах, где нужно вывести значение некоторых переменных на экран конструкцию вида
#ifdef DEBUG_OUT_L1
printf(“Some debug output %f\n“,someVariable);
#endif
После того, как ты нашел все ошибки ты не удлаяешь строчку #define DEBUG_OUT_L1, а просто комментируешь ее
//#define DEBUG_OUT_L1
Автоматически, когда программа собирается с закоментированной //#define DEBUG_OUT_L1 в нее не попадет отладочный вывод
но у тебя появляется возможность быстро снова его включить, просто раскоментировав в одном месте #define DEBUG_OUT_L1

По такому же принципу работает еще сборка программ под разные ОС. Например под MAC у тебя работает одна команда доступа
к файлам, а под Windows другая. Ты пишешь
#ifdef WINDOWS
//some windows related code
#elseif MAC
//soem MAC related code
#else
//other OS code
#endif

Макросы
Позволяют упростить и одновременно усложнить жизнь программистам :).
С одной стороны, он позволяют делать какие-то шаблоны, которые позволяют сократить к-во кода, которое ты пишешь
Например, тебе нужно часто писать variable*variable;
Ну ты придумываешь макрос
#define SQUARE(X) X*X
Он говорит, что везде в программе, где ты напишешь
int a = 10;
int b = SQUARE(a);
препроцессор потом напишет 
int b = a*a;
пока упрощение сомнительное, но если имена переменных будут длиннее
int c = SQUARE(someLongEnougName);
заменится на
int c = someLongEnougName*someLongEnougName;
все классно?
это быстрее чем функция, для вызова которой нужно использовать стэк , перемещаться на адрес функции, а потом возвращаться назад
в место вызова.
Но проблема в том, что здесь не интелектуальная подстановка
Допустим ты захотел написать int c = (a + b)^2; пишем int c = SQUARE(a + b); Так?
На самом деле препроцессор не столь интелектуален и выполнит этот код буквально
int c = a + b*a + b; Это тоже самое, что мы хотели?
Именно по-этому приходится макрос писать в виде 
#define SQUARE(X) ((X)*(X))
Из-за того, что с использованием макрософ вылезает много приколов и ньюансов чаще всего, если тебе нужно поведение функции - лучше
создать функцию. Так будет обслуживать программу проще и потом ошибки находить тоже намного проще.
Макросы используются при написании программ, которые пишут программы, так они могут оказаться очень полезными, но это нужен 
приличный опыт работы с ними, так что предлагаю на этом пока закончить их обсуждение ;)

Работа с регистрами через указатели
*((volatile unsigned char *)(0xFF50)) = someValue; //someValue - значение, которое занесли в регистр
0xFF50 - адрес памяти, по которому находится регистр
(volatile unsigned char *) - так как не используется переменная-указатель, то прежде чем обратится к адресу, нам нужно сказать
какого типа значение там хранится
volatile используем, так как это регистр и при работе с регистрами привыкнешь его писать :)
unsigned char - говорит, что это 1 байт без знака
* - что мы не просто написали число 0xFF50, а обращаемся по адресу 0xFF50 к значению, которое является unsigned char
Так если бы там хранилось число int, мы бы написали (volatile int *)
будь у нас указатель, было бы привычнее
volatile unsigned char* p = 0xFF50; //создали уже привычный нам указатель, который указывает на регистр по адресу 0xFF50
*p = someValue; // записали по этому адресу значение someValue
мне приятнее использовать указатель - он понятнее, хоть и немного длиннее
по сути запись (volatile unsigned char *)(0xFF50) - это команда создай временный указатель по адресу 0xFF50 на беззнаковый байт
*() вокруг (volatile unsigned char *)(0xFF50) - просто обертка, которая говорит - дай значение по этому адресу.
Когда явно используется указатель, то это упрощается до *p
если бы хотели прочитать значние из регистра, написали бы
volatile unsigned char someVariable = *((volatile unsigned char *)(0xFF50));
Но проще делать так
volatile unsigned char* someRegister = 0xFF50; //здесь в указатель один раз записали адрес и больше о нем не думаем
unsigned char a = *someRegister; //прочитать значение из регистра и записать в переменную a
*someRegister = 0x100;//записали значение 0х100 в регистр

В языке Си, который используется для работы с микроконтроллерами уже будет некоторое к-во заголовочных файлов вида 
tm4c1294ncpdt.h, в которых будут прописаны константы вида #define ADCSRA (*((volatile unsigned char *)(0xFF50)))
использыемые для работы с часто затребоваными регистрами
Тогда нету нужды помнить все эти адреса, а достаточно подключить в свою программу нужный заголовочный файл
#include "tm4c1294ncpdt.h"
и дальше везде, где нужен доступ к регистру ADCSRA писать просто
unsigned char someVariable = ADCSRA;

Манипуляция с битами, кратко повторим
Чтобы установить какой-то бит, нужно использовать битову операцию | (OR)
Например, у нас есть какая-то информация в регистре и нам нужно оставить ее неизменной, кроме бита с конкретным номером
1) Сначала нам нужно получить маску для этого бита. Это сделать очень просто, выполнить операцию 1 << bitNumber
Так если нам нужен 3й бит, пишем 1<<3 => 00001000. 
2) Теперь накладываем эту маску на существующее значение, каким бы оно не было, такая маска в паре с |(OR) не тронет ни один бит
кроме того, который есть в маске

Например, у нас в регистре 01100001 и нам нужно установить 3й бит, т.е. маска 00001000. Выполняем
 01100001
|
 00001000
=
 01101001
Как видим, изменился только 3й бит
Если нужно изменить больше одного бита, то эту операцию можно повторить несколько раз, каждый раз для очередного бита получив 
новую маску или поучить комбинированную маску.
Например, нам нужно установить бит 7, 5 и 3
маска для бита 7 = 1<<7, для бита 5 = 1<<5, для бита 3 = 1<<3. Объединенная маска (1<<7)|(1<<5)|(1<<3) = 10101000
После этого, все так же складываем эту маску с нашим регистром и получим гарантированную установку только 7, 5 и 3 го бита.
Например, в регистре 00000010
 00000010
|
 10101000
=
 10101010
 
 Главную идею, как работать с регистрами, и зачем все же нужны указатели ты понял ;)?
 
 
Clear bits 7,5,3,1,0:
Это значит, нужно выставить ноль в перечисленных битах и не тронуть остальные
Как и в прошлой задаче, мы не знаем, какие значения были во ВСЕХ битах до операции, это и не важно, битовые операции позволяют
изменить только те биты, которые нам нужны, не тронув остальные. Для того, чтобы выставить какой-то бит, мы на прошлом уроке
научились создавать маску и используя битовую операцию | устанавливать только необходимые биты.
Для очистки битов сначала тоже нужно сделать маску, только немного не так.
Нам нужно получить маску, которая будет иметь 0 против всех битов, которые мы хотим обунлить и 1 против всех остальных.
Так как мы знаем, что у нас всего 8 бит, то задачу можно немного упростить.
Создадим маску, как в прошлый раз, только с единичками против тех бит, которые мы не хотим менять.
И наложим эту маску на текущее значение, используя побитовую операцию &(AND)
 11111111 - здесь будет текущее состояние регистра, может быть каким угодно, 
			в худшем для очистки битов случае 11111111
& 			но может быть любым, для нас это не будет иметь значения
 01010100
=
 01010100
В случае, когда были все единицы, мы действительно получим такое же значение, как и маска, но попробуй наложить эту же маску 
на число 00011010
 00011010
&
 01010100
=
 00010000 - как видишь, сейчас мы получили другой результат. Биты в которых был 0 и которые мы не собирались трогать - остались 
 неизмененными
 
 Теперь вопрос, как получить, используя методику прошлого урока, маску 01010100?
Как используя операцию сдвига и | получить число 01010100
(1<<6)|(1<<4)|(1<<2)=01010100

Я предложил этот способ как максимально похожий на то, что мы делали на прошлом уроке.
Для создания маски, используем не те биты, которые нужно очистить, а те, которые нужно оставить нетронутыми.
Есть и другой способ получения тогоже, но чуть хитрее. Точно так же, как и раньше создадим маску на биты, которые нужно очистить
(1<<7)|(1<<5)|(1<<3)|(1<<1)|(1<<0)= 10101011
А теперь над этой маской проведем операцию инверсии ~. Она меняет один на ноь, а ноль на 1
~((1<<7)|(1<<5)|(1<<3)|(1<<1)|(1<<0)) = 01010100
Этот второй способ работает для всех случаев, а первый, который мы рассмотрели вначале, будет сложным, когда у нас будет 
не 1 байт, а 2 и больше
Так например, если нам нужно очистить все те же биты 7, 5, 3 и 2й, но уже в регистре из 2х байт, маска должна выглядеть
1111111101010100 и создать ее первым способом уже долго 
(1<<15)|(1<<14)|(1<<13)|(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<6)|(1<<4)|(1<<2)
А второй способ левый байт заполнит битами автоматически и останется таким же ~((1<<7)|(1<<5)|(1<<3)|(1<<1)|(1<<0))
Еще раз, я показал первый способ для очистки бит потому, что он был очень похож на способ установки бит, но универсальным есть 
инверсия

ADCSRA = ADCSRA & (~((1<<7)|(1<<5)|(1<<3)|(1<<1)|(1<<0)));
Здесь так много скобок потому, что инверсию нужно сделать не на (1<<7), а на все выражение (1<<7)|(1<<5)|(1<<3)|(1<<1)|(1<<0),
а третья пара потому, что & имеет свой приоритет и может выполнится раньше |. Надежнее все, в чем сомневаешься, оборачивать в скобки

(1<<7)|(1<<5) - Здесь скобки ставим потому, что операция << иммет самый низкий приоритет и 1<<7|1<<5 
компилятор поймет как (1<<(7|1))<<5, что не одно и тоже

Toggle the even bits
В данном случае просят изменить значение четных бит на противоположные (переключить их в противоположное значение).
Там где был 0 - выставить 1, там где был 1 - выставить 0.
1<<0 можно записать коротко как 1, но можно и так
 (1<<6)|(1<<4)|(1<<2)|(1<<0) = 01010101
 11111111
^
 01010101 
=
 10101010
 
 
 
 00000000
^
 01010101 
=
 01010101
 
 00001111
^
 01010101 
=
 01011010 
 
 Как видим, как и обещано, переключаются только те биты, против которых в маске мы поставили 1
 
 10010100
|
 ‭11000101‬
=
 11010101
 
 11010101
&
 ‭11110111‬
=
 11010101
 
 p.69
 
 10010100 & ~(1<<ADIF | 1<<ADPS1)
 (1<<ADIF | 1<<ADPS1) = (00010000 | 00000010)
 00010000
|
 00000010
=
 00010010
 
 ~00010010= 11101101
 
 10010100
& 
 11101101
=
 10000100
 
 Ты делал долго расчет, но с опытом приходит понимание, что делает эта последовательность без них
~(1<<ADIF | 1<<ADPS1) - делает маску для очистки битов, следовательно вместе с & мы просто очищаем биты с номерами 4 и 1
смотрим на 10010100 и после очистки этих бит получаем 10000100 - тоже самое, что после длинных расчетов ;)
Очистка бит - выставить в конкретных битах 0

Программирование микроконтроллеров
SYSCTL_RCGCGPIO_R |= (1<<3)|(1<<4);
SYSCTL_RCGCGPIO_R = SYSCTL_RCGCGPIO_R | (1<<3)|(1<<4);

while ((GPIO_PORTE_AHB_DATA_R & 0x01) == 0); // wait for button pushed

Обычно цикл while выглядит так
while(someCase)
{
}

здесь же while(someCase);
эта команда обозначает - не делай ничего, пока выполняется условие. Признак неделай ничего - это точка с запятой

смотрим внимательнее на услови (GPIO_PORTE_AHB_DATA_R & 0x01) == 0
оно состоит из двух частей
(GPIO_PORTE_AHB_DATA_R & 0x01) - первая, что она делает?

(GPIO_PORTE_AHB_DATA_R & 0x01)
эта команда очищает все биты кроме нулевого!
В результате, у нее есть два возможных результата, либо 1 в нулевом биты (так как все остальные делаем 0) либо 0
Первый результат возможен, если в нулевом биты была единица, второй - если 0
Следовательно проверка (GPIO_PORTE_AHB_DATA_R & 0x01) == 0 - говорит, "проверь, а 0 ли в нулевом бите ;)"
Судя по всему, когда в нулевом бите 0 - это признак того, что кнопка НЕ нажата и мы в таком случае ничего не делаем
Действительно while ((GPIO_PORTE_AHB_DATA_R & 0x01) == 0); можно перписать как
while ((GPIO_PORTE_AHB_DATA_R & 0x01) != 1); и это может быть понятнее

0x01 = 0000 0001
while ((GPIO_PORTE_AHB_DATA_R & 0x01) == 1);
Тогда этот цикл говорит, пока в нулевом бите 1 - не делай ничего, другими словами ждем, пока кнопка будет отпущена, после
чего в нулевом бите будет 0 и цикл закончится
т.е. "== 1" намекает на "проверь, а 1 ли в нулевом бите"


Blocking Polling (“busy wait”)
Есть два способа дождаться того, что мы получим изменение состояни того или иного регистра или чего либо другого.
Первый - как в примере выше опращивать постоянно значение и ничего не делать, пока не получим то, что ждем.
Это называется блокирующий вызов.

Interrupt
Это второй способ, так называемых прерываний. Для меня это давно забытое слово, так как оно низкоуровневое и я последний раз его
использовал на Assembler.
Этот способ намного более оптимальный, его прелесть в том, что мы получаем вызов кода только когда действительно произошло
какое-то событие.
Например, была нажата клавиша - будет вызвано прерывание отвечающее за обработку клавиша
Изменилось время (оно меняется не раз в секунду, а раз в некоторое к-во милисекунд) - будет вызвано прерывание, отвечающее
за обработку событий таймера и тп
Сейчас они просто в общих чертах об этом способе говорят, без конкретики, которая будет, я так понимаю, позднее ;)!!!!!!


p.82
#define LINFUNC(X) 5*X+3 /* calc. y=5*x+3 */
var1 = 3; y = 5*LINFUNC(2*var1+1);

y = 5*LINFUNC(2*3+1);
//y = 5*LINFUNC(7); ожидаемо, что будет так, но на самом деле, и в этом печаль, что нет
y = 5*LINFUNC(2*var1+1);
будет заменено препроцессором на 
y = 5*2*var1+1+3; а мы ведь ожидали y = 5*(2*var1+1)+3;
именно по этому в макросах приходится ставить скобки там, где в другом случае они не нужный
исправить нужно макрос: #define LINFUNC(X) 5*(X)+3 (добавили скобки для Х)
y = 5*(2*var1+1)+3;
y = 5*(7)+3;
y = 38

Это уже вторая задача!!!
The following macro is defined in param.h:
#define MIN(a,b) (((a)<(b))?(a):(b))
What does it do and for which arithmetic operation does a side-effect occur?

int c = MIN(5, 10);
int a = 5;
int b = 10;
ind d = MIN(a+b, a-b); //MIN(15,-5) - так ожидаем, но макросы работают не так. Именно в этом сайд эффект!
Задание здесь было в том, чтобы понять, что макрос всего лишь возвращает минимальное из двух значений
Теоретически, можно было написать без скобок
#define MIN(a,b) a<b?a:b
Но из-за того, что макросы обрабатываются как текст, при подстановке в макрос выражение получим не то, что ожидаем
(side effect) именно по этому приходится писать макросы используя идиотские скобки где только можно и именно по-этому
я рекомендую их (таких макросов) избегать вообще
#define MIN(a,b) a<b?a:b
ind d = MIN(a+b, a-b);
будет обработан как 
a+b<a-b?a+b:a-b
здесь не сравнится результат сложения и вычитания, а сложится a и b<a(которое будет равно либо 0 (когда b<a) либо 1 (иначе)) и
из этой суммы вычтется b
Другими словами, компилятор поймет это как
(a+(b<a))-b?a+b:a-b
(5+(10<5)-10 = 5+0- 10 = -5
-5?5+10:5-10
После того, как вычислили слева от ? это число сравнивается с 0, так как оно не равно нулю, возвращается то, что стоит до :.
Здесб двоеточие не "разделить"!!! это часть тернарного оператора. Разделить в языке Си /
Следовательно ответ этого выражения то, что стоит до : это 5+10 = 15
Получается, что в ответ на сравнение 15 и -5 мы получили ответ, что 15 меньше -5. Это бред.
Именно в этом побочный эффект этого макроса! Именно потому, чтобы не было такой ошибки ПРИХОДИТСЯ ставить скобки и писать
#define MIN(a,b) (((a)<(b))?(a):(b))
этот макрос будет работать без ошибок

допустим, что в ответ на сравнение 15 и -5 мы получили ответ, что 15 больше -5
нет, функция ведь называлась MIN, следовательно макрос безо всех скобок работает неправильно, именно потому их там так много
Это макрос не пишет ничего, он вернет одно из двух чисел. Когда он написан правильно, он возвращает всегда минимальное значение.
Задача была показать, что без скобок макрос может работать неправильно.
Почитай и попробуй использовать тернарный оператор в простой программе.
Мне нужно уже бежать 


A = GPIO_PORTA_DATA_R;
B = GPIO_PORTB_DATA_R;

/* clear bits 7,2,0 of A and assign result to C */

~((1<<7)|(1<<2)|(1<<0)) = ~(10000101) = 01111010
C = A & ~((1<<7)|(1<<2)|(1<<0));//можно написать так можно написать, так четко видно, какие биты очистили
C = A & 0x7A; //так тоже можно написать и будет правильно, но по коду не будет понятно, что мы сделали и придется смотреть в калькуляторе

/* clear bits 4:1 of B and assign result to D */
D = B & ~((1<<4)|(1<<3)|(1<<2)|(1<<1)|(1<<0));
/* replace bits 3:0 of A by bits 7:4 of B and assign to E*/это значит, что нужно установить биты в конкретные значения
в данном случае, нужно 3му биту переменной А присвоить тоже самое значение, что у 7го бита переменной B, 2му биту - 6й бит, 1му - 5й и 0му - 4й
E = A | B = 
здесь все намного сложнее, чем до этого было. Проблема в том, что для бит, которые нужно выставить в 0 - нужно делать очистку, а для 
тех, которые придется выставить в 1 - нужно делать установку.
Такую операцию можно сделать только для каждого бита написав проверку, если тот, который копируем - равен 1, то делаем для него маску
копирования, а для того, который равен 0 - маску очистки. Так как копируется 4 бита - нужно выполнить это действие 4 раза!

Думаю лучше всего привести сначала примере
Предположим мы копируем биты 7:4 переменной B в биты 3:0 переменной А.
B = 10101111
A = 00000000 любое значение, не важно какое, но напишем конкретное, чтобы было видно результат

Берем 7й бит переменной B, это 1, следовательно в 3й бит переменной A нужно произвести установку бита
Берем 6й бит переменной B, это 0, следовательно в 2й бите переменной A нужно произвести очистку бита
Берем 5й бит переменной B, это 1, следовательно в 1й бит переменной A нужно произвести установку бита
Берем 4й бит переменной B, это 0, следовательно в 0й бите переменной A нужно произвести очистку бита

другими словами, после выполнения этих операций переменная B не изменится, а в переменной A будет значение 00001010. Понятно почему?
Для того чтобы написать программу, нам нужно научиться выполнять еще одну битовую операцию - "тест бита"

Сам напишу
Тестирование бита похоже на установку, с небольшим добавлением
Маска создается, как для установки, но потом над этой маской проводят операцию & вместо | и сравнивают результат с 0. Если результат 
равен 0 - тестируемый бит 0, если неравен - 1.

Например
Нужно проверить бит 5 у переменной value со значения 1101111
Маска будет 1<<5, так как нас интересует 5й бит
и условие в программе пишем так
if (value & (1<<5) != 0)
	printf("5th bit is 1");
else
	printf("5th bit is 0"); 
	
как это работает?
 1101111
&
 0010000
=
 0000000 - результат равен 0 следовательно этот бит равен 0
 
 1111111
&
 0010000
=
 0010000 - результат НЕ равен 0 следовательно этот бит равен 1
 
Следовательно, задание сводится к тому, что нужно будет написать 4 if, по одному для каждого копируемого бита. Покажу как быть с первым
в задании, дальше сможешь дописать сам

if ((B & (1<<7)) != 0)
	E |= (1<<3);
else
	E &= ~(1<<3);
	
теперь допиши для остальных бит ;)
if ((B & (1<<6)) != 0)
	E |= (1<<2);
else
	E &= ~(1<<2);
	
if ((B & (1<<5)) != 0)
	E |= (1<<1);
else
	E &= ~(1<<1);
	
if ((B & (1<<4)) != 0)
	E |= (1<<0);
else
	E &= ~(1<<0);
	
/* replace bits 3:0 of A by bits 7:4 of B and assign to E*/	
Я понимаю это задание так
Нас интересует то, что было в переменной A, но часть ее битов нужно взять от переменной B и заменить ими биты в A и присвоить результат
переменной E, но при этом саму переменную A изменять не нужно!
Тогда мы просто копируем в переменную E, то, что было в переменной A, а потом все манипуляции проводить над переменой E

Так как биты и там и там идут по порядку, то можно использовать цикл
E = A;
int i;
for(i = 0; i < 4; ++i)//i =< 4 здесь две ошибки! правильно писать <= и если ты хочешь выполнить что-то n раз, то пищут i = 0; i < n; ++i
{
//в этом цикле осталось только немножко подправить и все будет ок. По сути для чисел из нуля нужно получить 7 в условии и 3 в манипуляции
//когда будем работать с 6м битом, нужно получить 6 в условии и 2 в манипуляции
//когда будем работать с 5м битом, нужно получить 5 в условии и 1 в манипуляции
//когда будем работать с 4м битом, нужно получить 4 в условии и 0 в манипуляции
	if ((B & (1<<(7-i))) != 0)
		E |= (1<<(3-i));
	else
		E &= ~(1<<(3-i));
}

