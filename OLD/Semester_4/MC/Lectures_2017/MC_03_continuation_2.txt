Who assigns a memory location (address) to a variable? 
При сборке программы есть несколько этапов. Препроцессинг, Компиляция, линковка (именно в этом порядке).
Компиляция - переводит текст на языке программирования в машинны или близкий к нему код (зависит от языка).
Линковка объединяет файлы в один и определяет относительные адреса каждого метода.

Потом, при выполнении, программа загружается в память начиная со свободного места в оперативной памяти, которое выделит
операционная система, и методы попадаю уже в конкретные адреса памяти, путем прибавления смещения к стартовому адресу памяти
который был выделен при старте программы.

Переменные бывают двух типов.
Локальные и те, которые выделяются в куче - глобальной памяти.
Локальные - это те переменные, которые ты создаешь в каждом методе.
Под все эти переменные память резервируется заранее и она имеет фиксированный размер. Сколько конкретно памяти выделить
определяет программист или IDE в момент компиляции и линковки программы (для тех, кто работает в Visual Studio 
это неразрывные процессы, но олдскульные программисты, запускали раньше последовательно для этого два различных приложения)
Так как память для локальных переменных имеет фиксированный размер, то теоретически можно получить ситуацию, что ее не хватило.
Именно по-этому были придуманы средства для работы с динамическими переменными. В языке Си - через указатели.
Но для начала закончим с локальными
Локальные переменные создаются по мере обращения к ним (того, как операционная система выполняет программу). 
Вот вызвал ты какой-то метод, в нем есть переменные - в области памяти локальных переменных будет найдено свободное место и 
каждая переменная получит свой уникальный адрес. Даже запуск два раза одной и той же программы не гарантирует, что одни
и теже переменные получат теже адреса памяти. На самом деле это и не важно, нам не важно знать конкертные адреса.
Нам достаточно быть уверенными, что памяти под эти переменные хватило и какой у них тип.
Тип определяет, сколько байт в памяти выделяется под каждую конкретную переменную.
Память под такие переменные, как правило, выделяется подряд.
Представим такую запись и что указатель свободной памяти указывает на адрес 0x100
int a; //4 bytes
byte b; //1 byte
short c;//2 bytes
float d;//4 bytes
double e;//8 bytes
Переменная a получит адрес 0x100 (при другом запуске программы это может быть другой адрес - не важно, 
рассматриваем какой-то конкретный случай). Так как типу int нужно 4 байта, то следующая переменна b получит адрес на 4 байта больше,
чем переменная a, а именно 0x100+4 = b:0x104
переменная c получит адрес на единицу дальше, чем переменная b, так как та имеет тип byte, следовательно c: 0x105

a: 0x100
b: 0x104
c: 0x105
d: 0x107
e: 0x10B //я специально придумал такие числа, чтобы здесь показать ньюанс. Адреса договорились подавать в 16й системе
об этом говорит 0x перед числом

Таим образом, на вопрос, кто выделяет память переменным - общий ответ операционная система или среда выполнения 
(например в Java - JRE, в C# - CLR. Не путать с IDE! В этих языках программы собираются в промежуточный код, который уже при работе
программы на лету компилируется в машинные коды средой выполненния)

How can we find out the address?
Сам адрес мы получаем при помощи оператора &. Указатели призваны дать возможно обращятся к этой памяти - читать/изменять ее.
Это же можно делать и при помощи переменных, но только простых.
Например массивы - это физически указатели, просто скрытые от программиста.

Еще немного о памяти и переменных.
Выше мы рассмотрели, как выделяется память под переменные, а что с массивами?
массив в языке Си - это переменная-указатель, которая всегда указывает на самый первый элемент массива, но используя
специальный синтаксис дает возможность обратится и к другим элементам.
Например
int arr[5] = {3, 5, 4, 2, -1};
По сути мы выделили память под идущие подряд 5 переменных типа int и переменная-указатель arr указывает на самый первый
Пусть этот массив начинается с области памяти 0x105, чтобы жизнь малиной не казалась ;)
arr: 0x105
Тогда запись arr[i] говорит, сместись относительно начала массива на i*sizeof(int) элементов (int, так как в примере массив int)
Конкретнее: arr[1] говорит элемент, который находится по адресу 0x105+1*4 = 0x109
arr[2] говорит элемент, который находится по адресу 0x105+2*4 = 0x10D 
arr[3] говорит элемент, который находится по адресу 0x105+3*4 = 0x111 (0x10D + 4 = 0x111 => 0x10D, 0x10E, 0x10F, 0x110, 0x111)
arr[4] говорит элемент, который находится по адресу 0x105+4*4 = 0x115 (0x111 + 4 = 0x115)

Другими словами, по можно записать какие значения хранятся по каким адресам:
arr[0] = 3:  0x105
arr[1] = 5:  0x109
arr[2] = 4:  0x10D
arr[3] = 2:  0x111
arr[4] = -1: 0x115

Теперь вопрос, а что произойдет, если написать arr[5] или arr[-1], что мы уже видели в лекции
Ответ: применяем туже самую формулу
arr[5]  0x105+5*4 = 0x119
arr[-1] 0x105+(-1)*4 = 0x101
Получается, с точки зрения программы мы можем обратится к области памяти, которая за пределами массива, что перед ним (отрицательное
смещение), что после него (индекс равный длинне массива и больше)
отрицательное смещение обычно указывает на область, которая была выделена ранее, следовательно попробовав изменить значение
через отрицательный индекс мы изменим какую-то переменную, которая была определена ранее
Например:
int a = 100;
int arr[5] = {3, 5, 4, 2, -1};
int b = 200;
arr[-1] = 50; // эта команда запишет в переменную "a" значение 50!!! Так как она была объявлена
прямо за 4 байта раньше массива и ее адрес 0x101
arr[5] = 30; // эта команда запишет 30 в переменную b, которая получит адрес сразу за границей массива!
Массив не может изменить свой размер после того, как был объявлен его размер. Так как под него память выделяется только раз!
В Джава массивы сделаны хитрее, они выделяются в куче и им можно потом перевыделить память и сослаться на новую, но не отвлекаемся.

Все может быть еще "веселее", например была такая запись (для 0x00 00 03 E8)
byte a = 100; 00     E8
byte b = 150; 00     03
byte c = 200; 03     00
byte d = 150; E8     00
int arr[5] = {3, 5, 4, 2, -1};
команда arr[-1] укажет на область памяти на 4 байта раньше начала массива и это переменная a!!! так как все переменные выше занимают
по одному байту
еще больше сюрприз будет если записать
arr[-1] = 1000;
эта команда изменит все 4 переменные (a, b, c, d)
смотрим в калькуляторе как именно. В 16ричной системе 1000 (10) = ‭‭0x3E8‬ (16). Если записать как 4 байта то это 0x00 00 03 E8
(один байт - это 2 шестнадцетиричные цифры). Следовательно, в зависимости от big / little endian мы запишем в a = 00 или E8
в b = 00 или 03 (0xE8 03 00 00), в c = 03 или 00 и в d = E8 или 00.
Вот такой неожиданный прикол. И главное в Си никто нас не предупредит, что произошел такой казус. А вот Java/Python/C# сразу скажут
так как они контролируют (за счет небольших издержек, чтобы все индексы попадали в границы массива)




Рассказываю как по значениею в 16чной системе понять сколько байт
каждые два символа - это один байт. Следовательно 1-2 символа - 1 байт, 3-4 - 2 байта, 5-6 - 3 байта и тд.
сколько нужно байт, чтобы сохранить значение 0xA1B3C5D4E7F1 ? Ответ: 6 байт
Если символов нечетное к-во - спопойно можно добавить самым первым 0, например 0xA12 = 0x0A12
Ну и тогда, сколько байт нужно для числа 0x45?

Для того, чтобы записать что-то по конкретному адресу - одно единственное решение, использовать указатель
byte* p = 0x2000; // так мы говорим, что указатель указывает именно по тому адресу, который просят
*p = 0x45; // записываем значение по адресу, на который указывает указатель

пожелание, указателям давать "p" в имени, тогда будет проще видеть, где указатель, а где обычные переменные

Теперь еще немножко о указателях и арифметических операциях с ними
Над указателями можно проводить несколько операций
Прибавить к адресу значение (тоже самое было с массивами arr[5] например, будет таже самая формула)
Вычесть из адреса значение (тоже самое было с массивами arr[-1] например, будет таже самая формула)
Инкременты/декременты - тоже самое, просто изменяем только на 1, но нужно смотреть они стоят перед или после указателям
Например *(p++), говорит, дай значение по адресу, куда сейчас указывает указатель, а его самого сдвинь впреде на следующий элемент
++p говорит дай адрес следующего элемента за адресом, куда указывает указатель и сам указатель передвинь на этот же адрес
Другими словами, нужно смотреть, есть ли звездочка, что-бы понять, что вернет команда: адрес(когда нет звездочки) или значение
(когда звездочка есть) и это будет по текущему адресу (++-- после указателя) или по измененному (++-- перед указателем)
Ну и чтобы решить это задание, нужно вспомнить битовые операции &(and) и |(or).
Так вот везде где стоят эти операторы, мы работаем не с адресом, а со значением
Нужно значение по полученному адресу перевести в двоичную систему (калькулятором) и выполнить действие над тем, что стоит за
бинарной операцией
Например:
byte a[3] = {100, 200, 250};
byte* p = a; //еще можно записать как &a[0], но это тоже самое
команда *(p++) & 30 говорит
возьми значение по текущему адресу (это начало массива, следовательно число 100) и
выполни с ним операцию & над другим числом (30)
эта же команда говорит: "указатель переведи после этого на следующие элемент (a[1])"
100 в двоичной системе ‭01100100‬
30 в двоичной системе ‭00011110‬
‭ 01100100‬
&
 ‭00011110‬
=
 00000100
Теперь смотрим, что в десятиричной системе это 8.
если после этого будет команда *(--p) | 20;
это значит, что нужно взять значение из ячейки перед текущей (это снова ячейка a[0], так как текущая была a[1]) = 8
и выполнить операцию 
 00000100
|
 ‭00010100‬
=
 00010100
 
0 & 0 = 0
1 & 0 = 0
0 & 1 = 0
1 & 1 = 1

0 | 0 = 0
1 | 0 = 1
0 | 1 = 1
1 | 1 = 1

~0 = 1
~1 = 0
;-)

Но не нужно инкремент путать с командами вида (p +- n)
Эта команда говорит "сразу прибавь/вычти из адреса". Здесь прячется маленький подвох!
Эта команда *(p+2) дает значение по новому адресу, но не изменяет сам указатель!
Другими словами, после нее указатель продолжит указывать на первый элемент массива!
Препод сделал задание с большим числом подвохов

Команды вида 1<<n 1>>n - это очень просто, просто двигаем единичку на указанное число бит

самая сложная и хитрая команда
*((p++)+1) | 23
она берет текущий адрес и к этому адресу прибавляет 1 - дает адрес следующего за текущим элементов
после этого берет значение, по получившемуся адресу (у нас это элемент &A[1])
влияние ++ имеет только на то, что после того, как закончится весь-весь расчет, она передвинет указатель на следующий элемент
но для вычисления числа она никакого влияния не имеет. А вот если бы было ++p, то мы бы получили в выражениее &A[2]
на самом деле (p++)+1 эквивалентно ++p и так, как написано в задании, никто не пишет, но препод хочет научить вас думать
текущее p++ (см. внизу про р++ и ++р) => 0xAA
+1 									  => 0xBB
итого, после расчёта *((p++)+1) | 23  => 0xBB
Пойми, команда p+1 не изменяет сам указатель, она дает ячейку за ним
а вот команда ++p изменяет его сразу
а вот команда p++ не изменяет его для вычисления выражения, но изменяет после того, как выражение будет обработано!

Determine the values of B,C,D after execution of the following program lines:
void main (void)
{
	char B,C,D;
	char A[] = {0xAA,0xBB,0xCD,0xFE};
	char *p = &A[1];  //0xBB
	B = *(p--) & 0x78;  //0xBB & 0x78 => 0x38; а после этого "p" становится &A[0]!
	C = *(p+2) & ~((1<<3)|(1<<7)); //0xAA => 0xCD, затем 0xCD & ~((1<<3)|(1<<7)
		//(1<<3)=> 0001<<3=1000		(1<<7)=> 0001<<7= 10000000
		//	00001000
		//  |
		//	10000000
		// =10001000
		//	~10001000 => 01110111
		// 
		//	‭11001101‬ (0xCD)
		//	&
		//	01110111
		// =01000101 => 0x45
		//после всего этого расчета p не изменится и останется указывать на &A[0]
	D = *((p++)+1) | 23; //  0xAA => 0xBB => 0xBB | 23 ......
		//0xBB = ‭10111011‬
		//		 |
		//23 = 	 ‭00010111‬
		//	   =>10111111 = 0xBF
...
}
Answer:
0xBB = ‭10111011‬
				&
0x78 = ‭01111000‬
				=
	   00111000 => 0x38
	   
	   
	   
	   
Главный вывод, что над указателями можно использовать арифметические операции, но не каждая из них изменяет сам указатель

Когда мы используем оператор вида *(p + someValue) - это означает возьми значение, которое смещено на someValue элементов после
элемента, на который указывает указатель
Когда мы используем оператор вида *(p - someValue) - это означает возьми значение, которое смещено на someValue элементов перед
элементом, на который указывает указатель
Эти команды возвращают значение из другой ячейки, но после их выполнения указатель не изменяет своего положения! Он указывают
на ту самую ячейку, куда указывал до этих команда
Можно еще увидеть запись вида p2 = p1 + someValue; или p2 = p1 - someValue;
Здесь p2 получит не новое значение (ибо нету значка *), а адрес новой ячейки, которая будет вычислена по тому-же самому правилу!
При этом переменная p1 не изменится ;)

Другим видом арифметических команд есть операторы инкремента/декремента.
Они мало того, что дают адрес, еще и изменяют сам указатель! Разница в том, до указателя они стоят или после
Если до - то в выражении будет использован новый адрес больше(++)/меньше(--) текущего на один элемент.
Сам указатель тоже сместится сразу на этот же новый адрес.
Если же ++/-- стоит ПОСЛЕ указателя - то в выражении будет использован текущий адрес указателя, и сам указатель изменит адрес
уже после того, как вся команда, в которой он выполняется, будет обработана.


	char A[] = {0xAA,0xBB,0xCD,0xFE};
	char *p = &A[1];  //0xBB - это не значение p, это значение по адресу, на которой он указывает!
	//какой конкретно адрес не важно, нужно главное понимать, что он указывает на элемент с индексом 1 в массиве A
	char* p2 = p--; //чему будет равняться p и p2 после выполнения этой команды?
	//p=0xAA   p2=0xBB правильно писать *p=0xAA   *p2=0xBB, а если говорить об адресах, то можно записать так
	//p=&A[0]   p2=&A[1]
	p2 = ((++p)+2); //p2=&A[3] p = &A[1]
	
	//(++p)+2 = p+3, но p = p + 1 произойдет сразу, так как ++ стоит до указателя
	//(p++)+2 = p+2, но p = p + 1 => именно так изменится переменная p после того, как вся эта команда выполнится
	
	p = p2 - 2; //p=&A[1] p2=&A[1] => ошибка, т.к. p2=&A[3]