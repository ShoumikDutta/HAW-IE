Проверим, что ты запомнил ;)

byte* p2;//это тоже создание указателя, просто ему пока не присвоен адрес,
			его можно (нужно!) присвоить позднее, до любого разыменовывания!
byte* p1 = 100; //главное нужно понять, что p1 - это указатель, указатель сначала должен получить адрес. Следовательно в самом 
начале указателю нельзя присвоить значение, только адрес либо переменной либо ячейки памяти!
Никогда при создании указателя не получится присвоить неясно какой ячейке значение!
p1 = 200; //тогда что делает эта команда, если ранее p1 был объявлен как указатель? даётся другой адрес
а если
*p1 = 300; // даётся значение на адрес 200

все три записи ниже равнозначны, но расскажу почему иногда пишут byte *p1 = 100;
byte *p1 = 100;
byte * p1 = 100;
byte* p1 = 100;

прикол еще в одном идиотизме Си
как ты думаешь, что создается такой командой?
int* a, b, c; //int *a, *b,*c; - это былобы логично, но в Си много чего нелогично :(
На самом деле это равносильно:
int* a;
int b;
int c;
Именно тот прикол, что звездочка относится к одной переменной заставляет людей придвигать ее к переменной, чтобы показать
что она все же принадлежит переменной. Но тогда возникает непонимание, когда создаешь переменную и разыменовываешь указатель
Так как запись, когда в одну строку создаются переменные лучше не использовать - многострочную проще коментировать и она 
читабельнее, то ситуаций с непонятками при int* a, b, c; автоматически избегаем и тогда новичку понятнее запись
int* a;//

Предлагаю проверить еще пару примеров, так как времени осталось мало, а еще углубиться мне тебя жалко ;)

short int a = 100;
short int b = 200;
short int *p3 = &a;
short int *p4 = &b;
short int *p5 = p3;//эта команда связывает p5 с a, используя p3, как посредник и все остальное время она связана с a
p3 = 100;
p3 = &b;
b = 150;
p3 = &a;
a = 50;

a = 50 , b = 150, *p3 = 50, *p4 = 150, *p5 = 50

*p3 = 70;
b = a;
a = 70 , b = 70, *p3 = 70, *p4 = 70, *p5 = 70
