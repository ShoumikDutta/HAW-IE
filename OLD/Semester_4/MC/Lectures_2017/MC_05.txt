#define DELAY 1//DELAY - это не переменная! Это макрос, который будет перед сборкой програмы везде заменен цифрой 1
unsigned long i;//i - это глобальная переменная, так как за пределами main в нашем примере

Дело в том, что макрос вида #define DELAY 1 это по сути константа, ему нельзя изменить значение в коде программы
В языке Си нету другой возможности создавать константы, кроме ущербных enum.
С точки зрения уже собранной программы, макроса нету вообще, в коде везде будет подставлено только значение и это быстрее, чем
использовать переменную.
Тот факт, что ты не можешь в выполняющейся программе изменить значение макроса - это важно для тех, кто потом читает код программы
Мозг отделяет те сущности, которые могут менять значения и которые не могут как разные понятия.
Для того, чтобы уже в самом коде было видно, что это не переменная, а макрос, договорились макросам давать имена только большими
буквами. Тогда такие имена сразу бросаются в глаза.
В СИ++ придумали другой способ создания констант, используя специальное слово const (final в Java), именно его рекомендубт
использовать вместо константных макросов, но в языке Си ничего менять не стали и по сути выбор не велик, либо макрос, либо enum

Коротко повторим основные операции над битами
a |= (1<<bit); или b = a | (1<<bit); ну или a = a | (1<<bit); что тоже самое, что и первая команда - установка конкретного бита
здесь главное - это операция |

a &= ~(1<<bit); или b = b & (1<<bit), третьего варианта нету! - очистка конкретного бита, Здесь главное &~.  Вот когда видишь 
такую комбинацию - у тебя сразу должен быть ответ - это очистка

(a & (1<<bit) == 0) - это проверка бита на 0.
(a & (1<<bit) != 0) - это проверка бита на 1
(a & (1<<bit) != (1 << bit)) - это тоже проверка бита на 1, только более длинная. Проверять a & (1<<bit) == 1 можно только
если ты тестируешь нулевой бит. Именно по-этому проще писать (a & (1<<bit) != 0), как более короткий варианта

Вот эти операции ты должен запомнить так, чтобы от зубов отскакивало и никогда их не путать ;)

Generate pulse of given length by “SW timer”
GPIO_PORTD_DATA_R |= 0x01; - это мы устанавливаем нулевой бит у GPIO_PORTD_DATA_R. Я так подозреваю, что это какой-то сигнал контроллеру
после которого мы ждем некоторое время
for (i=0;i<DELAY;i++) ;
это цикл, который ничего не делает столько раз, сколько записано в макросе DELAY. Ничего неделанье осуществляется за счет символа
точка-с-запятой
GPIO_PORTD_DATA_R &=~0x01; //да, это вторая из основных битовых операций, она очищает тот же бит, который был включен ранее
Судя по всему за счет включения, ожиданя некоторое время, очистки, мы и формируем pulse of given length. Чем больше будет значение
DELAY, тем больше будет пауза. Но как сказано в комментарии к лекции на длинну паузы еще влияет тип переменной цикла.

Measure pulse length by “SW timer”
А эта методика используется не когда мы похит подождать некоторое фиксированное время, а когда хотим замерять длительнось
какого-то события
Так же состоит из нескольки частей
1)
unsigned long ulCount = 0; //определяем переменную, которая будет подсчитывать длительность

что делает (GPIO_PORTD_DATA_R & 0x01)==0 ;)? Да, это проверка, что в в бите (в данном случае нулевом) находится 0
2)
while ((GPIO_PORTD_DATA_R & 0x01)==0); Следовательно этот цикл ждет и ничего не делает, пока в нулевом бите регистра GPIO_PORTD_DATA_R
записан 0, как только станет 1 - цикл прерывается и программа пойдет дальше

(GPIO_PORTD_DATA_R & 0x01)!=0, что делает эта команда ;)? Это проверка, что в бите (в данном случае нулевом) записан 1.
3)
while ((GPIO_PORTD_DATA_R & 0x01)!=0)
	ulCount++;
Следовательно этот кусочек, дождался, что в нулевом бите не 0 (это было в предыдущем пункте) и теперь, пока там 1, он увеличивает 
счетчик на 1, до тех пор, пока в нулевом бите регистра GPIO_PORTD_DATA_R снова не появится 0.

Таким образом. Этот работает как Stopwatch. Мы измеряем время с момента как нажали кнопку на секундомере (установка обнуленного бита в 1)
и до момента, как еще раз нажали или можно воспринимать как отпустили кнопку, путем обнуления этого же бита регистра.
Сколько раз за это время успеет выполнится цикл, именно такое число мы и получим в переменной ulCount
Скорее всего, есть связь между к-вом выполненных циклов и к-вом милисекунд, которому равен один период цикла.
Например, 1 проход цикла равен 1.5мс, мы намеряли ulCount = 6. Следовательно прошло 6*1.5мс = 9мс.
Конкретное время видимо тоже зависит от типа переменной ulCount. Это нужно уже смотреть в документации к микроконтроллеру, в лекции я
этого не увидел. 


#define DELAY 1
unsigned long i;
void main(void) {
	unsigned long j;
	...
	while(1){
		GPIO_PORTD_DATA_R = 0x03;
		for (i=0;i<DELAY;i++)
		;
		GPIO_PORTD_DATA_R = 0x02;
		for (j=0;j<DELAY;j++)
		;
		GPIO_PORTD_DATA_R = 0x01;
		for (j=0;j<DELAY;j++)
		;
		GPIO_PORTD_DATA_R = 0x00;
		for (i=0;i<DELAY;i++)
		;
	}
}

Здесь несколько "прикольчиков"
Первое, биты можно устанавливать/сбрасывать не только при помози битовых операций, но и путем присвоения конкретного значения
GPIO_PORTD_DATA_R = 0x03; //в бинарном виде это 00000011 - первый "прикольчик". Следовательно этой командой мы установили 
нулевой бит (запустили таймер) и первый бит, не знаю зачем :). В лекции не нашел, но пока это не важно
		for (i=0;i<DELAY;i++)
		;
Здесь мы ждем небольшое время.
GPIO_PORTD_DATA_R = 0x02; //в бинарном виде это 00000010. Следовательно мы нетронули 1 бит и сбросили нулевой - остановили таймер.
После этого
		for (j=0;j<DELAY;j++)
		;
ждет казалось бы такое же время, но "прикольчик" в том, что переменная j локальная (объявлена внутри текущего метода) и лекция нам
говорит, что такой цикл выполнится быстрее - значит пауза будет меньше, чем в прошлом цикле
далее выполняется GPIO_PORTD_DATA_R = 0x01; что она делает? Да она зачем-то сбросила первый бит и установила нулевой (снова запустила
таймер)
		for (j=0;j<DELAY;j++)
		;
этот цикл при включенном таймере выполнится меньше времени чем первый и столько же времени, что и второй. Но второй был при выключенном 
таймере, а этот и первый при включенном, следовательно, таймер в этот раз проработает меньше.
GPIO_PORTD_DATA_R = 0x00;
Ну и теперь мы снова сбросили таймер и снова подождали столько же, сколько и первый цикл
		for (i=0;i<DELAY;i++) 
		; //переносят на следующую строку только для человеческого восприятия, чтобы точно ее заметить, иначе она немного сливается
		
Я могу ошибаться, но мне кажется, что первый бит отвечал за высоту линии на графике
Типа сначала мы построили нижнюю линию на графике, а потом более коротку верхнюю. Выглядит логично, но можно спросить у препода

TIMER3_CFG_R |= 0x4;
Первое 0x4 это тоже самое, что и 4 в десятичной системе
Мне кажется здесь из 4 можно получить 16 путем 2^4 = 16
Типа мы передает степень двойки, а не само число, которое контроллер потом вычисляет сам. Ты в курсе, что 2^n = 1<<n ;)?
