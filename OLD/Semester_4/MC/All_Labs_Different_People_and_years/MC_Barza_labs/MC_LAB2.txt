/*---------------------------------------------------------------------------------------
 * Testprogram:  PortD Leds on/off
 * 	             Print "MP-Labor" on console
 *                                                                         - Prosch 3/2014
 *---------------------------------------------------------------------------------------
*/


#include "lm3s9b92.h"
#include "stdio.h"
#define TIMER 1000
void timerConfig();
void timerWait(unsigned short Usec);
void wait();


int main(void)
{
	int i;
	unsigned long  character[31]={0x00,0xFF,0x04,0x08,0x04,0xff, 0x00,0xFF,0x81,0x81,0x81,0x81,0x00,0xFF,0x80,0x80,0x80,0x80,0x00,0xFF,0x09,0x09,0x09,0xFF,0x00,0xFF,0x89,0x89,0x89,0xF7
	                            };
	// activate main oscillator at 16 MHz w/ external XTAL
	SYSCTL_RCC_R = ((SYSCTL_RCC_R | 0x00000540) & ~0x000002B1);
	//wait();
	//timerWait(TIMER);
	timerConfig();

	SYSCTL_RCGC2_R = (1<<3)|(1<<4); // clock Port D and E
	wait();
	//timerWait(TIMER);

	// configure port D as Output of MC and Input of Device
	GPIO_PORTD_DEN_R |= 0xFF; // PD(0) enable (7:0)
	GPIO_PORTD_DIR_R |= 0xFF; // PD(0) output (7:0)

	// configure port E as Input of MC and Output of Device
	GPIO_PORTE_DEN_R |= 0x01; // PD(0) enable (pin : 0)
	GPIO_PORTE_DIR_R |= 0x00; // PD(0) Input (pin : 0)


	while(1)
	{
	  while((GPIO_PORTE_DATA_R & 0x01) != 0x01)
	  {

	  }
/*	  GPIO_PORTD_DATA_R = 0xFF;
	  	   timerWait(TIMER);
	  GPIO_PORTD_DATA_R = 0x00; */
	// it's on Left Margin
	  for(i=0;i<30;i++)
	  {

	   GPIO_PORTD_DATA_R = character[i];
	   if (i < 4){
		   timerWait(TIMER*3);
	   }
	   else{
		   timerWait(TIMER);
	   }

//	   GPIO_PORTD_DATA_R = 0x00;
	  }

	 while((GPIO_PORTE_DATA_R&0x01) == 0x01)
	  {
		 GPIO_PORTD_DATA_R = 0x00;
	  }

	// it's on Right Margin
//	 GPIO_PORTD_DATA_R = 0xFF;
//	 timerWait(TIMER);
//	 GPIO_PORTD_DATA_R = 0x00;


	}


}

void wait(void){
	int i =0;
	for  (i =0;i < 1000; i++){

	}
}

void timerConfig(){
// configure Timer 0
  SYSCTL_RCGC1_R |= (1<<16);
  wait();
  TIMER0_CTL_R &= ~0x0001; // disable Timer 0
  TIMER0_CFG_R = 0x04; // 2 x 16-bit mode
  TIMER0_TAMR_R = 0x01; // periodic mode + match enable
  TIMER0_TAPR_R = 3-1; // prescaler PR = ceil((16Mhz/2^16)*10ms)-1
}


void timerWait(unsigned short Usec){
  TIMER0_TAILR_R = ((16*Usec)/3)-1; // ((16Mhz*Usec)/PR)-1
  //TIMER0_TAILR_R =
  TIMER0_CTL_R |= 0x0001;   //Enable the Timer
  while((TIMER0_RIS_R & (1<<0))==0)
   { // wait until the flag set

   }
  TIMER0_ICR_R |= (1<<0); //clear the interrupt flag
  TIMER0_CTL_R &= ~0x0001; //Disable the Timer
}
