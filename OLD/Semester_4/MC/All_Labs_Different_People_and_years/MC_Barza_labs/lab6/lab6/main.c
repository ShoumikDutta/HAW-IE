#define  PART_LM3S9B92

#include "lm3s9b92.h"
#include "stdio.h"
//#include "hw_types.h" // required for SysCtlClockSet
//#include "sysctl.h" // required for SysCtlClockSet
#include "int_handler.h" // #define CLOCKWISE / COUNTERCLOCKWISE
//#include <stdio.h>
#include <stdlib.h>
#include "int_UART2handler.h"

extern unsigned char ucDirection = CLOCKWISE; /* global variables */
extern unsigned char gucNewData = 0;
extern unsigned char gucRxChar = 0;



char array[][5] =	{
		{ 0x00, 0x00, 0x00, 0x00, 0x00 },   // sp
		{ 0x00, 0x00, 0x5f, 0x00, 0x00 },   // !
		{ 0x00, 0x07, 0x00, 0x07, 0x00 },   // "
		{ 0x14, 0x7f, 0x14, 0x7f, 0x14 },   // #
		{ 0x24, 0x2a, 0x7f, 0x2a, 0x12 },   // $
		{ 0xc4, 0xc8, 0x10, 0x26, 0x46 },   // %
		{ 0x36, 0x49, 0x55, 0x22, 0x50 },   // &
		{ 0x00, 0x05, 0x03, 0x00, 0x00 },   // '
		{ 0x00, 0x1c, 0x22, 0x41, 0x00 },   // (
		{ 0x00, 0x41, 0x22, 0x1c, 0x00 },   // )
		{ 0x14, 0x08, 0x3E, 0x08, 0x14 },   // *
		{ 0x08, 0x08, 0x3E, 0x08, 0x08 },   // +
		{ 0x00, 0x00, 0x50, 0x30, 0x00 },   // ,
		{ 0x10, 0x10, 0x10, 0x10, 0x10 },   // -
		{ 0x00, 0x60, 0x60, 0x00, 0x00 },   // .
		{ 0x20, 0x10, 0x08, 0x04, 0x02 },   // /
		{ 0x7C,0xA2,0x92,0x7C,0x00,},//0
		{0x42,0xFE,0x02,0x00,0x00},//1
		{ 0x46,0x8A,0x92,0x6,0x00},//2
		{0x84,0x92,0xB2,0xCC,0x00},//3
		{0x30,0x50,0x90,0xFE,0x00},//4
		{0xE4,0x92,0x92,0x8C,0x00},//5
		{0x7C,0x92,0x92,0x4C,0x00},//6
		{0x86,0x88,0x90,0xE0,0x00},//7
		{0xFE,0x92,0x92,0xFE,0x00},//8
		{0x60,0x90,0x90,0xFE,0x00},//9
		{ 0x00, 0x36, 0x36, 0x00, 0x00 },   // :
		{ 0x00, 0x56, 0x36, 0x00, 0x00 },   // ;
		{ 0x08, 0x14, 0x22, 0x41, 0x00 },   // <
		{ 0x14, 0x14, 0x14, 0x14, 0x14 },   // =
		{ 0x00, 0x41, 0x22, 0x14, 0x08 },   // >
		{ 0x02, 0x01, 0x51, 0x09, 0x06 },   // ?
		{ 0x32, 0x49, 0x59, 0x51, 0x3E },   // @
		{0x7E,0x90,0x90,0x7E,0x00},//A,
		{0xFE,0x92,0x92,0x6C,0x00},//B
		{0x7C,0x82,0x82,0x44,0x00},//C
		{0xFE,0x82,0x82,0x7C,0x00},//D
		{0xEE,0x92,0x92,0x92,0x00},//E
		{0xEE,0x90,0x90,0x90,0x00},//F
		{0x7C,0x82,0x82,0x1C,0x00},//G
		{0xFE,0x10,0x10,0xFE,0x00},//H
		{0x82,0xFE,0x82,0x00,0x00},//I
		{0x0C,0x02,0x02,0xEC,0x00},//J
		{0xFE,0x10,0x28,0xC6,0x00},//K
		{0xFE,0x02,0x02,0x02,0x00},//L
		{0xFE,0x20,0x10,0x20,0xFE},//M
		{0xFE,0x20,0x10,0x08,0xFE},//N
		{0x7C,0x82,0x82,0x7C,0x00},//O
		{0xFE,0x90,0x90,0x60,0x00},//P
		{0x7C,0x8A,0x86,0x7A,0x00},//Q
		{0xFE,0x90,0x98,0x66,0x00},//R
		{0x64,0x92,0x92,0x4C,0x00},//S
		{0x80,0xFE,0x80,0x00,0x00},//T
		{0xFC,0x02,0x02,0xFC,0x00},//U
		{0xF8,0x04,0x02,0x04,0xF8},//V
		{0xFE,0x04,0x18,0x04,0xFE},//W
		{0xC6,0x28,0x10,0x28,0xC6},//X
		{0x80,0x40,0x3E,0x40,0x80},//Y
		{0x86,0x8A,0x92,0xA2,0xC2},//Z
		{ 0x00, 0x7F, 0x41, 0x41, 0x00 },   // [
		{ 0x55, 0x2A, 0x55, 0x2A, 0x55 },   // 55
		{ 0x00, 0x41, 0x41, 0x7F, 0x00 },   // ]
		{ 0x04, 0x02, 0x01, 0x02, 0x04 },   // ^
		{ 0x40, 0x40, 0x40, 0x40, 0x40 },   // _
		{ 0x00, 0x01, 0x02, 0x04, 0x00 },   // '
		{ 0x20, 0x54, 0x54, 0x54, 0x78 },   // a
		{ 0x7F, 0x48, 0x44, 0x44, 0x38 },   // b
		{ 0x38, 0x44, 0x44, 0x44, 0x20 },   // c
		{ 0x38, 0x44, 0x44, 0x48, 0x7F },   // d
		{ 0x38, 0x54, 0x54, 0x54, 0x18 },   // e
		{ 0x08, 0x7E, 0x09, 0x01, 0x02 },   // f
		{ 0x0C, 0x52, 0x52, 0x52, 0x3E },   // g
		{ 0x7F, 0x08, 0x04, 0x04, 0x78 },   // h
		{ 0x00, 0x44, 0x7D, 0x40, 0x00 },   // i
		{ 0x20, 0x40, 0x44, 0x3D, 0x00 },   // j
		{ 0x7F, 0x10, 0x28, 0x44, 0x00 },   // k
		{ 0x00, 0x41, 0x7F, 0x40, 0x00 },   // l
		{ 0x7C, 0x04, 0x18, 0x04, 0x78 },   // m
		{ 0x7C, 0x08, 0x04, 0x04, 0x78 },   // n
		{ 0x38, 0x44, 0x44, 0x44, 0x38 },   // o
		{ 0x7C, 0x14, 0x14, 0x14, 0x08 },   // p
		{ 0x08, 0x14, 0x14, 0x18, 0x7C },   // q
		{ 0x7C, 0x08, 0x04, 0x04, 0x08 },   // r
		{ 0x48, 0x54, 0x54, 0x54, 0x20 },   // s
		{ 0x04, 0x3F, 0x44, 0x40, 0x20 },   // t
		{ 0x3C, 0x40, 0x40, 0x20, 0x7C },   // u
		{ 0x1C, 0x20, 0x40, 0x20, 0x1C },   // v
		{ 0x3C, 0x40, 0x30, 0x40, 0x3C },   // w
		{ 0x44, 0x28, 0x10, 0x28, 0x44 },   // x
		{ 0x0C, 0x50, 0x50, 0x50, 0x3C },   // y
		{ 0x44, 0x64, 0x54, 0x4C, 0x44 },   // z
		{ 0x08, 0x6C, 0x6A, 0x19, 0x08 },   // gramotevichka
		{ 0x0C, 0x12, 0x24, 0x12, 0x0C },   // | (sarce)
		{ 0x7E, 0x7E, 0x7E, 0x7E, 0x7E },    // kvadratche
};

//GLOBAL VARIABLE
char buffer[10];

void waitLoop() //waitLoop method
{
	int i;
	for (i= 0;i< 1000; i++)
		;
}

/*void configPortD(void) // PE(0):in+irq, PE(1):in, PE(3..2):out
{
int waitCycle=0;
SYSCTL_RCGC2_R = (1<<3); // activate PORTD clock
waitCycle++;
GPIO_PORTD_DEN_R |= 0x00FF; // enable pins (others remain 3-state)
GPIO_PORTD_DIR_R |= 0x00FC; // PortE(3..2) set direction to "output"
GPIO_PORTD_DATA_R &= 0x0000; // PortE(3..2) switch on LEDs
GPIO_PORTD_IS_R &= ~0x01; // interrupt sense to "edge-sensitive"
GPIO_PORTD_IBE_R &= ~0x01; // interrupt trigger set to "single edge"
GPIO_PORTD_IEV_R |= 0x01; // interrupt event to rising edge
GPIO_PORTD_ICR_R |= 0x01; // clear interrupt PORTE(0)
GPIO_PORTD_IM_R |= 0x01; // unmask PORTE(0) = S1
NVIC_EN0_R |= (1<<3); // enable PortD interrupt (Int#4/Vec#20) in NVIC
}*/

timerconfig(void ){

	SYSCTL_RCC_R = ((SYSCTL_RCC_R | 0x00000540) & ~0x000002B1);// activate main oscillator at 16 MHz w/ external XTAL
	waitLoop();
	SYSCTL_RCGC1_R |=(1<<16);//Activate Timer0A clock
	waitLoop();
	TIMER0_CTL_R &= ~0x0001; // disable Timer 0A
	TIMER0_CFG_R = 0x04; // 2 x 16-bit mode
	TIMER0_TAMR_R = 0x01; // periodic mode
	TIMER0_TAPR_R = 2;//prescalar =(tmax*16MH)/2^16

}

void timerWait(int time){//Wait time is in ms
	TIMER0_TAILR_R=time*6;
	TIMER0_CTL_R |= 0x0001; // enable Timer 0A
	while((TIMER0_RIS_R & (1<<0))==0);//wait until time-out
}



//GLOBAL VARIABLE


int main(){

	SYSCTL_RCGC2_R |= ((1 << 8) | (1 << 4)|(1<<3)) ;
	waitLoop();
	GPIO_PORTJ_DEN_R = 0xFF;
	GPIO_PORTJ_DIR_R = 0xFF;
	GPIO_PORTE_DEN_R = 0x01;
	GPIO_PORTE_DIR_R = 0x00;
	GPIO_PORTD_DEN_R |= 0x00FF; // enable pins (others remain 3-state)
	GPIO_PORTD_DIR_R |= 0x00FC; // PortE(3..2) set direction to "output"
	GPIO_PORTD_DATA_R &= 0x0000; // PortE(3..2) switch on LEDs
	GPIO_PORTD_IS_R &= ~0x01; // interrupt sense to "edge-sensitive"
	GPIO_PORTD_IBE_R &= ~0x01; // interrupt trigger set to "single edge"
	GPIO_PORTD_IEV_R |= 0x01; // interrupt event to rising edge
	GPIO_PORTD_ICR_R |= 0x01; // clear interrupt PORTE(0)
	GPIO_PORTD_IM_R |= 0x01; // unmask PORTE(0) = S1
	NVIC_EN0_R |= (1<<3); // enable PortD interrupt (Int#4/Vec#20) in NVIC
	//configPortD();
	waitLoop();//
	timerconfig();//
	waitLoop();//
	// initialize Port G
	SYSCTL_RCGC2_R |= 0x00000040; // switch on clock for Port G
	waitLoop();// wait for clock to stabilize
	GPIO_PORTG_DEN_R |= 0x01; // PG(0) digital I/O enable
	GPIO_PORTG_DIR_R &= ~0x01; // PG(0) output----//sending//------
	GPIO_PORTG_AFSEL_R |= 0x001; // PG(0) alternate function
	GPIO_PORTG_PCTL_R |= 0x00000001; // PG(0) alternate function is U2Rx
	SYSCTL_RCGC1_R |= 0x00000004;// switch on clock for UART2

	waitLoop(); // short delay for stable clock
	UART2_CTL_R &= ~0x0001; // disable UART2 for configuration
	UART2_IBRD_R = 8; // set DIVINT of BRD (bitrate 115200bit/s)
	UART2_FBRD_R = 44; // set DIVFRAC of BRD
	UART2_LCRH_R = 0x00000060; // serial format 8N1
	UART2_CTL_R |= 0x0001; // start UART2
	UART2_ICR_R = 0xE7FF;//----
	UART2_IM_R = 1<<4;//------
	NVIC_EN1_R |= 1<<(33-32);//-----

	int i=0;



	i=0;
	while(1){
		while((GPIO_PORTE_DATA_R &0x01) != 1){}
		int l;
		if(gucNewData){
			buffer[i%10] = gucRxChar;
			gucNewData = 0;
			i++;
		}
		timerWait(5000);
		for(l=0;l<10;l++){
			int dec = buffer[l];
			int j=0;

			for(j=0;j<5;j++){
				if(ucDirection==1){
					timerWait(800);
					GPIO_PORTJ_DATA_R = array[dec-32][j];
				}
				else {
					timerWait(800);
					GPIO_PORTJ_DATA_R = ~array[dec-32][j];
				}
				timerWait(800);
				GPIO_PORTJ_DATA_R = 0x00;
 				//timerWait(1);
				TIMER0_ICR_R|= (1<<0);//Time-out flag cleared
				TIMER0_CTL_R &= ~0x0001;//disable Timer0A


			}

		}
		while((GPIO_PORTE_DATA_R &0x01) == 1){}//Exit when port is low

	/*	for (l=0;l<10;l++) {
			int j=0;
			for(j=0;j<5;j++){
				timerWait(800);
				TIMER0_ICR_R|= (1<<0);//Time-out flag cleared
			}
		}*/

	}

}

