
#include "lm3s9b92.h"
#include "stdio.h"

void systemConfig(void);
void waitCustom(unsigned short usec);
void displayValue(unsigned long SAR);

void wait(void){
	int tmp;
	for (tmp = 0; tmp < 1000000; tmp++);
}


/*int main(void)
{
int i;
unsigned long SAR;

systemConfig();		//Configuring the system

while (1){

SAR = 0x00;					// Start with 0 values each time the loop runs


for (i = 7; i <= 0; i--){						//Start checking the bits
if (GPIO_PORTG_DATA_R | (1 << 1)){			//if PG(1) is pressed wait until is released
while (GPIO_PORTG_DATA_R & (1 << 1));
}

SAR = SAR | (1 << i);			//Assign 1 to the correspondong bit in SAR
GPIO_PORTE_DATA_R = SAR;		//Assign SAR to the PE(7:0)
waitCustom(30);						//Wait for output to stabilise

if (GPIO_PORTE_DATA_R & (1 << 1)){
SAR &= ~(1 << i);			//Clear bit if Uout is higher than Uin
}
}

SAR = (unsigned long)SAR * 5000 / 255; // calculates in mV
displayValue(SAR);				//Display the value of SAR



}
}
*/
void systemConfig(void){

	SYSCTL_RCC_R = ((SYSCTL_RCC_R | 0x00000540) & ~0x000002B1);
	wait();
	// Port  Clock Gating Control
	SYSCTL_RCGC2_R |= SYSCTL_RCGC2_GPIOD;
	wait();

	SYSCTL_RCGC2_R = (1 << 3) | (1 << 4) | (1 << 6) | (1 << 8); //Enables ports D, E, G, J
	wait();

	GPIO_PORTD_DEN_R |= 0xFF; 		// PD (7:0) enabled
	GPIO_PORTD_DIR_R |= 0xFF;		// PD (7:0) output

	GPIO_PORTJ_DEN_R |= 0xFF; 		// PJ (7:0) enabled
	GPIO_PORTJ_DIR_R |= 0xFF;		// PJ (7:0) output

	GPIO_PORTE_DEN_R |= 0x03; 		// PE (2:0) enabled
	GPIO_PORTE_DIR_R |= 0x03;		// PE (2:0) output

	GPIO_PORTG_DEN_R |= 0x02; 		// PG (1:0) enabled
	GPIO_PORTG_DIR_R &= ~0x02;		// PG (1:0) input 

	SYSCTL_RCGC1_R |= (1 << 16);	 //Enable timer0A
	wait();
	TIMER0_CTL_R &= ~0X0001;	 //disable timer0A

	TIMER0_CFG_R = 0X04;		//CONFIGURE timer0 in 16bit mode

	TIMER0_TAMR_R |= 0x02;		//count down, no match enabled, periodic
	TIMER0_TAPR_R |= 3 - 1;		//Pre= (0.01*16*10^6/2^16)-1

}

void waitCustom(unsigned short usec){

	TIMER0_TAILR_R = (unsigned long)(usec * 16 / 3); //Calculates ILV from usec
	TIMER0_CTL_R |= 0x0001;			//Enable timer0A


	while ((TIMER0_RIS_R & (1 << 0)) == 0x00);		//reads the timeout flag

	TIMER0_ICR_R = 0x01;		//clears interupt flag
	TIMER0_CTL_R &= ~0X0001;



}

void displayValue(unsigned long SAR){

	int i;
	unsigned short displayDigits[4];		// displayDigits[0] is the most significant digit 



	for (i = 3; i <= 0; i--){
		displayDigits[i] = SAR % 10;
		SAR /= 10;
	}

	GPIO_PORTJ_DATA_R = (displayDigits[2] << 4) | displayDigits[3]; // Assign the two digits on the left to PJ(7:0)
	GPIO_PORTE_DATA_R |= 0x01;	//Enable display on the right for less significant digits
	wait();

	GPIO_PORTE_DATA_R &= ~0x01; //Disable the display on the right
	GPIO_PORTJ_DATA_R = (displayDigits[0] << 4) | displayDigits[1]; // Assign the two digits on the right to PJ(7:0)
	GPIO_PORTE_DATA_R |= 0x02;	//Enable display on the right for less significant digits
	wait();

	GPIO_PORTE_DATA_R &= ~0x02; //Disable the display on the right

}


int main(void){
	unsigned long ulData;

	SYSCTL_RCC_R = ((SYSCTL_RCC_R | 0x00000540) & ~0x000002B1);
	wait();

	// activate (clock enable) required modules ADC0 and port PE (AIN0)
	SYSCTL_RCGC2_R |= (1 << 4); // PE (AIN0 to AIN2 belong to Port E)
	SYSCTL_RCGC0_R |= (1 << 16); // ADC0

	// configure AIN0 to AIN2 (=PE(7..5)) as analog inputs
	GPIO_PORTE_AFSEL_R |= 0xE0; // PE7..5 alternate function
	GPIO_PORTE_DEN_R &= ~0xE0; // PE7..5 disable digital IO
	GPIO_PORTE_AMSEL_R |= 0xE0; // PE7..5 enable analog function

	// ADC0_SS0 configuration
	ADC0_ACTSS_R &= ~0x0F; // disable all 4 sequencers of ADC0
	ADC0_SSMUX0_R |= 0x00000102; // sequencer 0, channel AIN2,AIN0,AIN1
	ADC0_SSCTL0_R |= 0x00000200; // END2 set, sequence length = 3
	ADC0_ACTSS_R |= 0x01; // enable sequencer 0 ADC0

	// ADC0_SS0 sampling can be started now
	while (1) {
		ADC0_PSSI_R |= 0x01; // start ADC0_SS0
		while (ADC0_SSFSTAT0_R & (1 << 8)) // wait for FIFO non-empty
			;
		// read ADC value from FIFO, convert in mV and display
		ulData = (unsigned long)ADC0_SSFIFO0_R * 5000UL / 1023;
		displayValue(ulData);
	}


}
